{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.proveLT\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">proveLT</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Prove goals of the form `A < B` in an ordered commutative semiring, if the ring-normal forms of\n`A` and `B` differ by a positive (additive) constant. ","docLink":"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.proveLT","kind":"def","line":231,"name":"Mathlib.Tactic.Ring.proveLT","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Compare.lean#L231-L254"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.proveLE\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">proveLE</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Prove goals of the form `A ≤ B` in an ordered commutative semiring, if the ring-normal forms of\n`A` and `B` differ by a nonnegative (additive) constant. ","docLink":"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.proveLE","kind":"def","line":205,"name":"Mathlib.Tactic.Ring.proveLE","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Compare.lean#L205-L228"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.lt_congr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">lt_congr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LT\">LT</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c </span><span class=\"fn\">d</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h1</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h2</span> : <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">c</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h3</span> : <span class=\"fn\">d</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">d</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.lt_congr","kind":"theorem","line":200,"name":"Mathlib.Tactic.Ring.lt_congr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Compare.lean#L200-L202"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.le_congr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">le_congr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c </span><span class=\"fn\">d</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h1</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h2</span> : <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">c</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h3</span> : <span class=\"fn\">d</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">d</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.le_congr","kind":"theorem","line":196,"name":"Mathlib.Tactic.Ring.le_congr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Compare.lean#L196-L198"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.evalLT\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalLT</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ics</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x✝</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/PartialOrder.html#PartialOrder\">PartialOrder</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Order/Ring/Defs.html#IsStrictOrderedRing\">IsStrictOrderedRing</a> <span class=\"fn\">«$α»</span></span>)</span> →\n  <span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>} → <span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">q(<span class=\"fn\">«$ics»</span>)</span> <span class=\"fn\">a</span></span>) → <span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">q(<span class=\"fn\">«$ics»</span>)</span> <span class=\"fn\">b</span></span>) → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Except\">Except</a> <a href=\"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.ExceptType\">ExceptType</a> <span class=\"fn\">Q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">«$b»</span>)</span>)</span></span></span></span></span></span></div></div>","info":{"doc":"In a commutative semiring, given `Ring.ExSum` objects `va`, `vb` which differ by a positive\n(additive) constant, construct a proof of `$a < $b`, where `a` (resp. `b`) is the expression in the\nsemiring to which `va` (resp. `vb`) evaluates. ","docLink":"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.evalLT","kind":"def","line":159,"name":"Mathlib.Tactic.Ring.evalLT","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Compare.lean#L159-L194"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.evalLE\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalLE</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ics</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x✝</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/PartialOrder.html#PartialOrder\">PartialOrder</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Order/Ring/Defs.html#IsOrderedRing\">IsOrderedRing</a> <span class=\"fn\">«$α»</span></span>)</span> →\n  <span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>} → <span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">q(<span class=\"fn\">«$ics»</span>)</span> <span class=\"fn\">a</span></span>) → <span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">q(<span class=\"fn\">«$ics»</span>)</span> <span class=\"fn\">b</span></span>) → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Except\">Except</a> <a href=\"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.ExceptType\">ExceptType</a> <span class=\"fn\">Q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">«$b»</span>)</span>)</span></span></span></span></span></span></div></div>","info":{"doc":"In a commutative semiring, given `Ring.ExSum` objects `va`, `vb` which differ by a positive\n(additive) constant, construct a proof of `$a < $b`, where `a` (resp. `b`) is the expression in the\nsemiring to which `va` (resp. `vb`) evaluates. ","docLink":"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.evalLE","kind":"def","line":121,"name":"Mathlib.Tactic.Ring.evalLE","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Compare.lean#L121-L157"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.ExceptType.notComparable\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExceptType</span>.<span class=\"name\">notComparable</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.ExceptType\">ExceptType</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.ExceptType.notComparable","kind":"ctor","line":118,"name":"Mathlib.Tactic.Ring.ExceptType.notComparable","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Compare.lean#L118-L118"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.ExceptType.tooSmall\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExceptType</span>.<span class=\"name\">tooSmall</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.ExceptType\">ExceptType</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.ExceptType.tooSmall","kind":"ctor","line":118,"name":"Mathlib.Tactic.Ring.ExceptType.tooSmall","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Compare.lean#L118-L118"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.ExceptType\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExceptType</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Inductive type carrying the two kinds of errors which can arise in the metaprograms\n`Mathlib.Tactic.Ring.evalLE.lean` and `Mathlib.Tactic.Ring.evalLT.lean`. ","docLink":"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.ExceptType","kind":"inductive","line":116,"name":"Mathlib.Tactic.Ring.ExceptType","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Compare.lean#L116-L118"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.lt_add_of_pos_left\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">lt_add_of_pos_left</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/PartialOrder.html#PartialOrder\">PartialOrder</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Order/Ring/Defs.html#IsStrictOrderedRing\">IsStrictOrderedRing</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">b</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.lt_add_of_pos_left","kind":"theorem","line":109,"name":"Mathlib.Tactic.Ring.lt_add_of_pos_left","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Compare.lean#L109-L112"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.add_lt_of_neg_left\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">add_lt_of_neg_left</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/PartialOrder.html#PartialOrder\">PartialOrder</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Order/Ring/Defs.html#IsStrictOrderedRing\">IsStrictOrderedRing</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">0</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">a</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.add_lt_of_neg_left","kind":"theorem","line":104,"name":"Mathlib.Tactic.Ring.add_lt_of_neg_left","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Compare.lean#L104-L107"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.add_lt_add_left\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">add_lt_add_left</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/PartialOrder.html#PartialOrder\">PartialOrder</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Order/Ring/Defs.html#IsStrictOrderedRing\">IsStrictOrderedRing</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b </span><span class=\"fn\">c</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">bc</span> : <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">c</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">c</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.add_lt_add_left","kind":"theorem","line":99,"name":"Mathlib.Tactic.Ring.add_lt_add_left","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Compare.lean#L99-L102"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.le_add_of_nonneg_left\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">le_add_of_nonneg_left</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/PartialOrder.html#PartialOrder\">PartialOrder</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Order/Ring/Defs.html#IsOrderedRing\">IsOrderedRing</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.le_add_of_nonneg_left","kind":"theorem","line":94,"name":"Mathlib.Tactic.Ring.le_add_of_nonneg_left","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Compare.lean#L94-L97"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.add_le_of_nonpos_left\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">add_le_of_nonpos_left</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/PartialOrder.html#PartialOrder\">PartialOrder</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Order/Ring/Defs.html#IsOrderedRing\">IsOrderedRing</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">0</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">a</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.add_le_of_nonpos_left","kind":"theorem","line":89,"name":"Mathlib.Tactic.Ring.add_le_of_nonpos_left","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Compare.lean#L89-L92"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.add_le_add_left\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">add_le_add_left</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/PartialOrder.html#PartialOrder\">PartialOrder</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Order/Ring/Defs.html#IsOrderedRing\">IsOrderedRing</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b </span><span class=\"fn\">c</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">bc</span> : <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">c</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">c</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.add_le_add_left","kind":"theorem","line":84,"name":"Mathlib.Tactic.Ring.add_le_add_left","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Compare.lean#L84-L87"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.lt_of_po\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">lt_of_po</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/PartialOrder.html#PartialOrder\">PartialOrder</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#LT\">LT</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"`PartialOrder` implies `LT`. ","docLink":"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.lt_of_po","kind":"def","line":64,"name":"Mathlib.Tactic.Ring.lt_of_po","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Compare.lean#L64-L65"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.le_of_po\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">le_of_po</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/PartialOrder.html#PartialOrder\">PartialOrder</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"`PartialOrder` implies `LE`. ","docLink":"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.le_of_po","kind":"def","line":61,"name":"Mathlib.Tactic.Ring.le_of_po","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Compare.lean#L61-L62"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.amwo_of_cs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">amwo_of_cs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne\">AddMonoidWithOne</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"`CommSemiring` implies `AddMonoidWithOne`. ","docLink":"./Mathlib/Tactic/Ring/Compare.html#Mathlib.Tactic.Ring.amwo_of_cs","kind":"def","line":58,"name":"Mathlib.Tactic.Ring.amwo_of_cs","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Ring/Compare.lean#L58-L59"}}],"imports":["Init","Mathlib.Tactic.Ring.Basic","Mathlib.Tactic.NormNum.Ineq","Mathlib.Tactic.NormNum.Ineq","Mathlib.Tactic.Ring.Basic"],"instances":[],"name":"Mathlib.Tactic.Ring.Compare"}