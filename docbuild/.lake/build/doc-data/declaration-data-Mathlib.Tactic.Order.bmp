{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.tacticOrder_\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">tacticOrder_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"A finishing tactic for solving goals in arbitrary `Preorder`, `PartialOrder`,\nor `LinearOrder`. Supports `⊤`, `⊥`, and lattice operations. ","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.tacticOrder_","kind":"def","line":304,"name":"Mathlib.Tactic.Order.tacticOrder_","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Order.lean#L304-L308"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.order_core\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">order_core</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`order_core` is the part of the `order` tactic that tries to find a contradiction. ","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.order_core","kind":"def","line":292,"name":"Mathlib.Tactic.Order.order_core","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Order.lean#L292-L293"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.orderArgs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">orderArgs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Args for the `order` tactic. ","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.orderArgs","kind":"def","line":289,"name":"Mathlib.Tactic.Order.orderArgs","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Order.lean#L289-L290"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.orderCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">orderCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">only?</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hyps</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">negGoal</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Core of the `order` tactic. ","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.orderCore","kind":"def","line":285,"name":"Mathlib.Tactic.Order.orderCore","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Order.lean#L285-L287"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.orderCoreImp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">orderCoreImp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">only?</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hyps</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">negGoal</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Implementation of `orderCore` in `AtomM`. ","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.orderCoreImp","kind":"def","line":235,"name":"Mathlib.Tactic.Order.orderCoreImp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Order.lean#L235-L283"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.instOrdProdNatExpr_mathlib\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">instOrdProdNatExpr_mathlib</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord\">Ord</a> (<a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></div></div>","info":{"doc":"Necessary for tracing below. ","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.instOrdProdNatExpr_mathlib","kind":"def","line":231,"name":"Mathlib.Tactic.Order.instOrdProdNatExpr_mathlib","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Order.lean#L231-L233"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.updateGraphWithNltInfSup\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">updateGraphWithNltInfSup</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Mathlib/Tactic/Order/Graph/Basic.html#Mathlib.Tactic.Order.Graph\">Graph</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">facts</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/Order/CollectFacts.html#Mathlib.Tactic.Order.AtomicFact\">AtomicFact</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <a href=\"./Mathlib/Tactic/Order/Graph/Basic.html#Mathlib.Tactic.Order.Graph\">Graph</a></span></div></div>","info":{"doc":"Adds edges to the `≤`-graph using two types of facts:\n1. Each fact `¬ (x < y)` allows to add the edge `(x, y)` when `y` is reachable from `x` in the\ngraph.\n2. Each fact `x ⊔ y = z` allows to add the edge `(z, s)` when `s` is reachable from both `x`\nand `y`.\n\nWe repeat the process until no more edges can be added. ","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.updateGraphWithNltInfSup","kind":"def","line":186,"name":"Mathlib.Tactic.Order.updateGraphWithNltInfSup","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Order.lean#L186-L229"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.findContradictionWithNle\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">findContradictionWithNle</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Mathlib/Tactic/Order/Graph/Basic.html#Mathlib.Tactic.Order.Graph\">Graph</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">facts</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/Order/CollectFacts.html#Mathlib.Tactic.Order.AtomicFact\">AtomicFact</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"Using the `≤`-graph `g`, find a contradiction with some `≰`-fact. ","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.findContradictionWithNle","kind":"def","line":177,"name":"Mathlib.Tactic.Order.findContradictionWithNle","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Order.lean#L177-L184"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.findContradictionWithNe\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">findContradictionWithNe</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">graph</span> : <a href=\"./Mathlib/Tactic/Order/Graph/Basic.html#Mathlib.Tactic.Order.Graph\">Graph</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">facts</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/Order/CollectFacts.html#Mathlib.Tactic.Order.AtomicFact\">AtomicFact</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"Finds a contradictory `≠`-fact whose `.lhs` and `.rhs` belong to the same strongly connected\ncomponent in the `≤`-graph, implying they must be equal, and then uses it to derive `False`. ","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.findContradictionWithNe","kind":"def","line":157,"name":"Mathlib.Tactic.Order.findContradictionWithNe","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Order.lean#L157-L175"}}],"imports":["Init","Mathlib.Tactic.Order.CollectFacts","Mathlib.Tactic.Order.Graph.Basic","Mathlib.Tactic.ByContra","Mathlib.Tactic.Order.CollectFacts","Mathlib.Tactic.Order.Graph.Basic","Mathlib.Tactic.Order.Graph.Tarjan","Mathlib.Tactic.Order.Preprocessing","Mathlib.Tactic.Order.ToInt","Mathlib.Util.ElabWithoutMVars"],"instances":[],"name":"Mathlib.Tactic.Order"}