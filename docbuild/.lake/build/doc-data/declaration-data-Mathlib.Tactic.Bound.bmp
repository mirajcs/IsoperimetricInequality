{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Bound.html#«tacticBound[_]»\"><span class=\"name\">«tacticBound[_]»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`bound` tactic for proving inequalities via straightforward recursion on expression structure.\n\nAn example use case is\n\n```\n-- Calc example: A weak lower bound for `z ↦ z^2 + c`\nlemma le_sqr_add (c z : ℝ) (cz : ‖c‖ ≤ ‖z‖) (z3 : 3 ≤ ‖z‖) :\n    2 * ‖z‖ ≤ ‖z^2 + c‖ := by\n  calc ‖z^2 + c‖\n    _ ≥ ‖z^2‖ - ‖c‖ := by bound\n    _ ≥ ‖z^2‖ - ‖z‖ := by  bound\n    _ ≥ (‖z‖ - 1) * ‖z‖ := by\n      rw [mul_comm, mul_sub_one, ← pow_two, ← norm_pow]\n    _ ≥ 2 * ‖z‖ := by bound\n```\n\n`bound` is built on top of `aesop`, and uses\n1. Apply lemmas registered via the `@[bound]` attribute\n2. Forward lemmas registered via the `@[bound_forward]` attribute\n3. Local hypotheses from the context\n4. Optionally: additional hypotheses provided as `bound [h₀, h₁]` or similar. These are added to the\n   context as if by `have := hᵢ`.\n\nThe functionality of `bound` overlaps with `positivity` and `gcongr`, but can jump back and forth\nbetween `0 ≤ x` and `x ≤ y`-type inequalities.  For example, `bound` proves\n  `0 ≤ c → b ≤ a → 0 ≤ a * c - b * c`\nby turning the goal into `b * c ≤ a * c`, then using `mul_le_mul_of_nonneg_right`.  `bound` also\ncontains lemmas for goals of the form `1 ≤ x, 1 < x, x ≤ 1, x < 1`.  Conversely, `gcongr` can prove\ninequalities for more types of relations, supports all `positivity` functionality, and is likely\nfaster since it is more specialized (not built atop `aesop`). ","docLink":"./Mathlib/Tactic/Bound.html#«tacticBound[_]»","kind":"def","line":214,"name":"«tacticBound[_]»","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Bound.lean#L214-L244"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Bound.html#Mathlib.Tactic.Bound.boundConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Bound</span>.<span class=\"name\">boundConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Aesop/Options/Public.html#Aesop.Options\">Aesop.Options</a></div></div>","info":{"doc":"Aesop configuration for `bound` ","docLink":"./Mathlib/Tactic/Bound.html#Mathlib.Tactic.Bound.boundConfig","kind":"def","line":206,"name":"Mathlib.Tactic.Bound.boundConfig","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Bound.lean#L206-L210"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Bound.html#Mathlib.Tactic.Bound.boundLinarith\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Bound</span>.<span class=\"name\">boundLinarith</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Aesop/RuleTac/Basic.html#Aesop.RuleTac\">Aesop.RuleTac</a></div></div>","info":{"doc":"Close numerical and other goals with `linarith` ","docLink":"./Mathlib/Tactic/Bound.html#Mathlib.Tactic.Bound.boundLinarith","kind":"def","line":195,"name":"Mathlib.Tactic.Bound.boundLinarith","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Bound.lean#L195-L199"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Bound.html#Mathlib.Tactic.Bound.boundNormNum\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Bound</span>.<span class=\"name\">boundNormNum</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Aesop/RuleTac/Basic.html#Aesop.RuleTac\">Aesop.RuleTac</a></div></div>","info":{"doc":"Close numerical goals with `norm_num` ","docLink":"./Mathlib/Tactic/Bound.html#Mathlib.Tactic.Bound.boundNormNum","kind":"def","line":186,"name":"Mathlib.Tactic.Bound.boundNormNum","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Bound.lean#L186-L192"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Bound.html#Mathlib.Tactic.Bound.min_lt_of_left_lt_or_right_lt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Bound</span>.<span class=\"name\">min_lt_of_left_lt_or_right_lt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/LinearOrder.html#LinearOrder\">LinearOrder</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">c</span> <a href=\"./Init/Prelude.html#Or\">∨</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">c</span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Min.min\">min</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">c</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Bound.html#Mathlib.Tactic.Bound.min_lt_of_left_lt_or_right_lt","kind":"theorem","line":167,"name":"Mathlib.Tactic.Bound.min_lt_of_left_lt_or_right_lt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Bound.lean#L167-L167"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Bound.html#Mathlib.Tactic.Bound.min_le_of_left_le_or_right_le\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Bound</span>.<span class=\"name\">min_le_of_left_le_or_right_le</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/LinearOrder.html#LinearOrder\">LinearOrder</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">c</span> <a href=\"./Init/Prelude.html#Or\">∨</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">c</span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Min.min\">min</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">c</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Bound.html#Mathlib.Tactic.Bound.min_le_of_left_le_or_right_le","kind":"theorem","line":166,"name":"Mathlib.Tactic.Bound.min_le_of_left_le_or_right_le","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Bound.lean#L166-L166"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Bound.html#Mathlib.Tactic.Bound.lt_max_of_lt_left_or_lt_right\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Bound</span>.<span class=\"name\">lt_max_of_lt_left_or_lt_right</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/LinearOrder.html#LinearOrder\">LinearOrder</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Or\">∨</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Max.max\">max</a> <span class=\"fn\">b</span> <span class=\"fn\">c</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Bound.html#Mathlib.Tactic.Bound.lt_max_of_lt_left_or_lt_right","kind":"theorem","line":165,"name":"Mathlib.Tactic.Bound.lt_max_of_lt_left_or_lt_right","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Bound.lean#L165-L165"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Bound.html#Mathlib.Tactic.Bound.le_max_of_le_left_or_le_right\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Bound</span>.<span class=\"name\">le_max_of_le_left_or_le_right</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/LinearOrder.html#LinearOrder\">LinearOrder</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Or\">∨</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Max.max\">max</a> <span class=\"fn\">b</span> <span class=\"fn\">c</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Bound.html#Mathlib.Tactic.Bound.le_max_of_le_left_or_le_right","kind":"theorem","line":164,"name":"Mathlib.Tactic.Bound.le_max_of_le_left_or_le_right","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Bound.lean#L164-L164"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Bound.html#Mathlib.Tactic.Bound.Nat.one_le_cast_of_le\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Bound</span>.<span class=\"name\">Nat</span>.<span class=\"name\">one_le_cast_of_le</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Data/Nat/Cast/Defs.html#AddCommMonoidWithOne\">AddCommMonoidWithOne</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/PartialOrder.html#PartialOrder\">PartialOrder</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Order/Monoid/Unbundled/Defs.html#AddLeftMono\">AddLeftMono</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Order/ZeroLEOne.html#ZeroLEOneClass\">ZeroLEOneClass</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharZero/Defs.html#CharZero\">CharZero</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">1</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">n</span> → <span class=\"fn\">1</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">↑<span class=\"fn\">n</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Bound.html#Mathlib.Tactic.Bound.Nat.one_le_cast_of_le","kind":"theorem","line":110,"name":"Mathlib.Tactic.Bound.Nat.one_le_cast_of_le","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Bound.lean#L110-L113"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Bound.html#Mathlib.Tactic.Bound.Nat.cast_pos_of_pos\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Bound</span>.<span class=\"name\">Nat</span>.<span class=\"name\">cast_pos_of_pos</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/PartialOrder.html#PartialOrder\">PartialOrder</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Order/Ring/Defs.html#IsOrderedRing\">IsOrderedRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Logic/Nontrivial/Defs.html#Nontrivial\">Nontrivial</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">n</span> → <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">↑<span class=\"fn\">n</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Bound.html#Mathlib.Tactic.Bound.Nat.cast_pos_of_pos","kind":"theorem","line":106,"name":"Mathlib.Tactic.Bound.Nat.cast_pos_of_pos","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Bound.lean#L106-L108"}}],"imports":["Init","Aesop","Mathlib.Tactic.Bound.Attribute","Mathlib.Tactic.Lemma","Mathlib.Tactic.NormNum.Core","Mathlib.Tactic.Bound.Attribute","Mathlib.Tactic.Linarith.Frontend"],"instances":[],"name":"Mathlib.Tactic.Bound"}