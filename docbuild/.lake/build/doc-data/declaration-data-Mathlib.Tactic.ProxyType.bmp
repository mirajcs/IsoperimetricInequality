{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.elab_proxy_equiv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">ProxyType</span>.<span class=\"name\">elab_proxy_equiv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElab\">Lean.Elab.Term.TermElab</a></div></div>","info":{"doc":"Elaborator for `proxy_equiv%`. ","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.elab_proxy_equiv","kind":"def","line":291,"name":"Mathlib.ProxyType.elab_proxy_equiv","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/ProxyType.lean#L291-L300"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.proxy_equiv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">ProxyType</span>.<span class=\"name\">proxy_equiv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The term elaborator `proxy_equiv% α` for a type `α` elaborates to an equivalence `β ≃ α`\nfor a \"proxy type\" `β` composed out of basic type constructors `Unit`, `PLift`, `Sigma`,\n`Empty`, and `Sum`.\n\nThis only works for inductive types `α` that are neither recursive nor have indices.\nIf `α` is an inductive type with name `I`, then as a side effect this elaborator defines\n`I.proxyType` and `I.proxyTypeEquiv`.\n\nThe elaborator makes use of the expected type, so `(proxy_equiv% _ : _ ≃ α)` works.\n\nFor example, given this inductive type\n```\ninductive foo (n : Nat) (α : Type)\n  | a\n  | b : Bool → foo n α\n  | c (x : Fin n) : Fin x → foo n α\n  | d : Bool → α → foo n α\n```\nthe proxy type it generates is `Unit ⊕ Bool ⊕ (x : Fin n) × Fin x ⊕ (_ : Bool) × α` and\nin particular we have that\n```\nproxy_equiv% (foo n α) : Unit ⊕ Bool ⊕ (x : Fin n) × Fin x ⊕ (_ : Bool) × α ≃ foo n α\n```\n","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.proxy_equiv","kind":"def","line":264,"name":"Mathlib.ProxyType.proxy_equiv","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/ProxyType.lean#L264-L289"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.elabProxyEquiv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">ProxyType</span>.<span class=\"name\">elabProxyEquiv</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">type</span> : <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expectedType?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Declaration.html#Lean.InductiveVal\">Lean.InductiveVal</a>)</span></div></div>","info":{"doc":"Helper function for `proxy_equiv% type : expectedType` elaborators.\n\nElaborate `type` and get its `InductiveVal`. Uses the `expectedType`, where the\nexpected type should be of the form `_ ≃ type`. ","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.elabProxyEquiv","kind":"def","line":246,"name":"Mathlib.ProxyType.elabProxyEquiv","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/ProxyType.lean#L246-L262"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ensureProxyEquiv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">ProxyType</span>.<span class=\"name\">ensureProxyEquiv</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">config</span> : <a href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig\">ProxyEquivConfig</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">indVal</span> : <a href=\"./Lean/Declaration.html#Lean.InductiveVal\">Lean.InductiveVal</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Generates a proxy type for the inductive type and an equivalence from the proxy type to the type.\n\nIf the declarations already exist, there is a check that they are correct.\n","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ensureProxyEquiv","kind":"def","line":149,"name":"Mathlib.ProxyType.ensureProxyEquiv","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/ProxyType.lean#L149-L244"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.default\"><span class=\"name\">Mathlib</span>.<span class=\"name\">ProxyType</span>.<span class=\"name\">ProxyEquivConfig</span>.<span class=\"name\">default</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">indVal</span> : <a href=\"./Lean/Declaration.html#Lean.InductiveVal\">Lean.InductiveVal</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig\">ProxyEquivConfig</a></div></div>","info":{"doc":"Default configuration. Defines `proxyType` and `proxyTypeEquiv` in the namespace\nof the inductive type. Uses `Unit`, `PLift`, `Sigma`, `Empty`, and `Sum`. ","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.default","kind":"def","line":141,"name":"Mathlib.ProxyType.ProxyEquivConfig.default","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/ProxyType.lean#L141-L147"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.defaultMkProxyType\"><span class=\"name\">Mathlib</span>.<span class=\"name\">ProxyType</span>.<span class=\"name\">defaultMkProxyType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ctors</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Lean.Term</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">decorateSum</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span> := <a href=\"./Init/Prelude.html#Pure.pure\">pure</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Lean.Term</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`tactic</span>)</span></div></div>","info":{"doc":"Create a `Sum` of types, mildly optimized to not have a trailing `Empty`.\n\nThe `decorateSum` function is to wrap the `Sum` with a function such as `Lex`.\nIt should yield a definitionally equal type. ","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.defaultMkProxyType","kind":"def","line":104,"name":"Mathlib.ProxyType.defaultMkProxyType","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/ProxyType.lean#L104-L139"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.defaultMkCtorProxyType\"><span class=\"name\">Mathlib</span>.<span class=\"name\">ProxyType</span>.<span class=\"name\">defaultMkCtorProxyType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">xs</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">decorateSigma</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span> := <a href=\"./Init/Prelude.html#Pure.pure\">pure</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Lean.Term</a>)</span></div></div>","info":{"doc":"Returns a proxy type for a constructor and a pattern to use to match against it.\n\nInput: a list of pairs associated to each argument of the constructor consisting\nof (1) an fvar for this argument and (2) a name to use for this argument in patterns.\n\nFor example, given `#[(a, x), (b, y)]` with `x : Nat` and `y : Fin x`, then this function\nreturns `Sigma (fun x => Fin x)` and `⟨a, b⟩`.\n\nAlways returns a `Type*`. Uses `Unit`, `PLift`, and `Sigma`. Avoids using `PSigma` since\nthe `Fintype` instances for it go through `Sigma`s anyway.\n\nThe `decorateSigma` function is to wrap the `Sigma` a decorator such as `Lex`.\nIt should yield a definitionally equal type. ","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.defaultMkCtorProxyType","kind":"def","line":68,"name":"Mathlib.ProxyType.defaultMkCtorProxyType","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/ProxyType.lean#L68-L102"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.mkProxyType\"><span class=\"name\">Mathlib</span>.<span class=\"name\">ProxyType</span>.<span class=\"name\">ProxyEquivConfig</span>.<span class=\"name\">mkProxyType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig\">ProxyEquivConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Lean.Term</a>)</span> → <span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Lean.Term</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`tactic</span>)</span></span></div></div>","info":{"doc":"Given (constructor name, proxy constructor type, proxy constructor pattern) triples\nconstructed using `mkCtorProxyType`, return (1) the total proxy type (a `Type*`),\n(2) patterns to use for each constructor, and (3) a proof to use to prove `left_inv` for\n`proxy_type ≃ type` (this proof starts with `intro x`). ","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.mkProxyType","kind":"def","line":66,"name":"Mathlib.ProxyType.ProxyEquivConfig.mkProxyType","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/ProxyType.lean#L66-L66"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.mkCtorProxyType\"><span class=\"name\">Mathlib</span>.<span class=\"name\">ProxyType</span>.<span class=\"name\">ProxyEquivConfig</span>.<span class=\"name\">mkCtorProxyType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig\">ProxyEquivConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span> → <span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span></div></div>","info":{"doc":"Returns a proxy type for a constructor and a pattern to use to match against it,\ngiven a list of fvars for the constructor arguments and pattern names to use for the arguments.\nThe proxy type is expected to be a `Type*`. ","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.mkCtorProxyType","kind":"def","line":61,"name":"Mathlib.ProxyType.ProxyEquivConfig.mkCtorProxyType","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/ProxyType.lean#L61-L61"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.proxyEquivName\"><span class=\"name\">Mathlib</span>.<span class=\"name\">ProxyType</span>.<span class=\"name\">ProxyEquivConfig</span>.<span class=\"name\">proxyEquivName</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig\">ProxyEquivConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></div></div>","info":{"doc":"Name to use for the declaration for the equivalence `proxyType ≃ type`. ","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.proxyEquivName","kind":"def","line":57,"name":"Mathlib.ProxyType.ProxyEquivConfig.proxyEquivName","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/ProxyType.lean#L57-L57"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.proxyName\"><span class=\"name\">Mathlib</span>.<span class=\"name\">ProxyType</span>.<span class=\"name\">ProxyEquivConfig</span>.<span class=\"name\">proxyName</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig\">ProxyEquivConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></div></div>","info":{"doc":"Name to use for the declaration for a type that is `Equiv` to the given type. ","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.proxyName","kind":"def","line":55,"name":"Mathlib.ProxyType.ProxyEquivConfig.proxyName","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/ProxyType.lean#L55-L55"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">ProxyType</span>.<span class=\"name\">ProxyEquivConfig</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proxyName </span><span class=\"fn\">proxyEquivName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mkCtorProxyType</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span> → <span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mkProxyType</span> :\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> (<a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Lean.Term</a>)</span> → <span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Lean.Term</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`tactic</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig\">ProxyEquivConfig</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.mk","kind":"ctor","line":53,"name":"Mathlib.ProxyType.ProxyEquivConfig.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/ProxyType.lean#L53-L53"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">ProxyType</span>.<span class=\"name\">ProxyEquivConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Configuration used by `mkProxyEquiv`. ","docLink":"./Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig","kind":"structure","line":52,"name":"Mathlib.ProxyType.ProxyEquivConfig","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/ProxyType.lean#L52-L66"}}],"imports":["Init","Mathlib.Logic.Equiv.Defs","Mathlib.Tactic.Simps.Basic"],"instances":[],"name":"Mathlib.Tactic.ProxyType"}