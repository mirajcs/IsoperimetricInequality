{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#fieldLt\"><span class=\"name\">fieldLt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc\">Lean.Meta.Simp.Simproc</a></div></div>","info":{"doc":"The goal of the simprocs grouped under the `field` attribute is to clear denominators in\n(semi-)field (in)equalities, by bringing LHS and RHS each over a common denominator and then\ncross-multiplying. For example, the `field` simproc will clear the `x` denominators in the following\nequation:\n```\nexample {K : Type*} [Field K] {x : K} (hx0 : x ≠ 0) :\n    (x + 1 / x) ^ 2 + (x + 1 / x) = 1 := by\n  simp only [field]\n  -- new goal: `⊢ (x ^ 2 + 1) * (x ^ 2 + 1 + x) = x ^ 2`\n```\n\nThe `field` simproc-set's functionality is a variant of the more general `field_simp` tactic, which\nnot only clears denominators in field (in)equalities but also brings isolated field expressions into\nthe normal form `n / d` (where neither `n` nor `d` contains any division symbol). (For confluence\nreasons, the `field` simprocs also have a slightly different normal form from `field_simp`'s.)\n\nCancelling and combining denominators will generally require checking \"nonzeroness\"/\"positivity\"\nside conditions. The `field` simproc-set attempts to discharge these, and will omit such steps if it\ncannot discharge the corresponding side conditions. The discharger will try, among other things,\n`positivity` and `norm_num`, and will also use any nonzeroness/positivity proofs included explicitly\nin the simp call (e.g. `simp [field, hx]`). If your (in)equality is not completely reduced by the\n`field` simproc-set, check the denominators of the resulting (in)equality and provide proofs that\nthey are nonzero/positive to enable further progress.\n","docLink":"./Mathlib/Tactic/FieldSimp.html#fieldLt","kind":"def","line":788,"name":"fieldLt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L788-L788"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#fieldLe\"><span class=\"name\">fieldLe</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc\">Lean.Meta.Simp.Simproc</a></div></div>","info":{"doc":"The goal of the simprocs grouped under the `field` attribute is to clear denominators in\n(semi-)field (in)equalities, by bringing LHS and RHS each over a common denominator and then\ncross-multiplying. For example, the `field` simproc will clear the `x` denominators in the following\nequation:\n```\nexample {K : Type*} [Field K] {x : K} (hx0 : x ≠ 0) :\n    (x + 1 / x) ^ 2 + (x + 1 / x) = 1 := by\n  simp only [field]\n  -- new goal: `⊢ (x ^ 2 + 1) * (x ^ 2 + 1 + x) = x ^ 2`\n```\n\nThe `field` simproc-set's functionality is a variant of the more general `field_simp` tactic, which\nnot only clears denominators in field (in)equalities but also brings isolated field expressions into\nthe normal form `n / d` (where neither `n` nor `d` contains any division symbol). (For confluence\nreasons, the `field` simprocs also have a slightly different normal form from `field_simp`'s.)\n\nCancelling and combining denominators will generally require checking \"nonzeroness\"/\"positivity\"\nside conditions. The `field` simproc-set attempts to discharge these, and will omit such steps if it\ncannot discharge the corresponding side conditions. The discharger will try, among other things,\n`positivity` and `norm_num`, and will also use any nonzeroness/positivity proofs included explicitly\nin the simp call (e.g. `simp [field, hx]`). If your (in)equality is not completely reduced by the\n`field` simproc-set, check the denominators of the resulting (in)equality and provide proofs that\nthey are nonzero/positive to enable further progress.\n","docLink":"./Mathlib/Tactic/FieldSimp.html#fieldLe","kind":"def","line":787,"name":"fieldLe","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L787-L787"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#fieldEq\"><span class=\"name\">fieldEq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc\">Lean.Meta.Simp.Simproc</a></div></div>","info":{"doc":"The goal of the simprocs grouped under the `field` attribute is to clear denominators in\n(semi-)field (in)equalities, by bringing LHS and RHS each over a common denominator and then\ncross-multiplying. For example, the `field` simproc will clear the `x` denominators in the following\nequation:\n```\nexample {K : Type*} [Field K] {x : K} (hx0 : x ≠ 0) :\n    (x + 1 / x) ^ 2 + (x + 1 / x) = 1 := by\n  simp only [field]\n  -- new goal: `⊢ (x ^ 2 + 1) * (x ^ 2 + 1 + x) = x ^ 2`\n```\n\nThe `field` simproc-set's functionality is a variant of the more general `field_simp` tactic, which\nnot only clears denominators in field (in)equalities but also brings isolated field expressions into\nthe normal form `n / d` (where neither `n` nor `d` contains any division symbol). (For confluence\nreasons, the `field` simprocs also have a slightly different normal form from `field_simp`'s.)\n\nCancelling and combining denominators will generally require checking \"nonzeroness\"/\"positivity\"\nside conditions. The `field` simproc-set attempts to discharge these, and will omit such steps if it\ncannot discharge the corresponding side conditions. The discharger will try, among other things,\n`positivity` and `norm_num`, and will also use any nonzeroness/positivity proofs included explicitly\nin the simp call (e.g. `simp [field, hx]`). If your (in)equality is not completely reduced by the\n`field` simproc-set, check the denominators of the resulting (in)equality and provide proofs that\nthey are nonzero/positive to enable further progress.\n","docLink":"./Mathlib/Tactic/FieldSimp.html#fieldEq","kind":"def","line":786,"name":"fieldEq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L786-L786"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.proc\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">proc</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc\">Lean.Meta.Simp.Simproc</a></div></div>","info":{"doc":"The goal of the simprocs grouped under the `field` attribute is to clear denominators in\n(semi-)field (in)equalities, by bringing LHS and RHS each over a common denominator and then\ncross-multiplying. For example, the `field` simproc will clear the `x` denominators in the following\nequation:\n```\nexample {K : Type*} [Field K] {x : K} (hx0 : x ≠ 0) :\n    (x + 1 / x) ^ 2 + (x + 1 / x) = 1 := by\n  simp only [field]\n  -- new goal: `⊢ (x ^ 2 + 1) * (x ^ 2 + 1 + x) = x ^ 2`\n```\n\nThe `field` simproc-set's functionality is a variant of the more general `field_simp` tactic, which\nnot only clears denominators in field (in)equalities but also brings isolated field expressions into\nthe normal form `n / d` (where neither `n` nor `d` contains any division symbol). (For confluence\nreasons, the `field` simprocs also have a slightly different normal form from `field_simp`'s.)\n\nCancelling and combining denominators will generally require checking \"nonzeroness\"/\"positivity\"\nside conditions. The `field` simproc-set attempts to discharge these, and will omit such steps if it\ncannot discharge the corresponding side conditions. The discharger will try, among other things,\n`positivity` and `norm_num`, and will also use any nonzeroness/positivity proofs included explicitly\nin the simp call (e.g. `simp [field, hx]`). If your (in)equality is not completely reduced by the\n`field` simproc-set, check the denominators of the resulting (in)equality and provide proofs that\nthey are nonzero/positive to enable further progress.\n","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.proc","kind":"def","line":746,"name":"Mathlib.Tactic.FieldSimp.proc","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L746-L780"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.convField_simp__\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">convField_simp__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The goal of the `field_simp` conv tactic is to bring an expression in a (semi-)field over a common\ndenominator, i.e. to reduce it to an expression of the form `n / d` where neither `n` nor `d`\ncontains any division symbol. For example, `x / (1 - y) / (1 + y / (1 - y))` is reduced to\n`x / (1 - y + y)`:\n```\nexample (x y z : ℚ) (hy : 1 - y ≠ 0) :\n    ⌊x / (1 - y) / (1 + y / (1 - y))⌋ < 3 := by\n  conv => enter [1, 1]; field_simp\n  -- new goal: `⊢ ⌊x / (1 - y + y)⌋ < 3`\n```\n\nAs in this example, cancelling and combining denominators will generally require checking\n\"nonzeroness\" side conditions. The `field_simp` tactic attempts to discharge these, and will omit\nsuch steps if it cannot discharge the corresponding side conditions. The discharger will try, among\nother things, `positivity` and `norm_num`, and will also use any nonzeroness proofs included\nexplicitly (e.g. `field_simp [hx]`). If your expression is not completely reduced by `field_simp`,\ncheck the denominators of the resulting expression and provide proofs that they are nonzero to\nenable further progress.\n\nThe `field_simp` conv tactic is a variant of the main (i.e., not conv) `field_simp` tactic. The\nlatter operates recursively on subexpressions, bringing *every* field-expression encountered to the\nform `n / d`.\n","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.convField_simp__","kind":"def","line":713,"name":"Mathlib.Tactic.FieldSimp.convField_simp__","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L713-L744"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.fieldSimp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">fieldSimp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The goal of `field_simp` is to bring expressions in (semi-)fields over a common denominator, i.e. to\nreduce them to expressions of the form `n / d` where neither `n` nor `d` contains any division\nsymbol. For example, `x / (1 - y) / (1 + y / (1 - y))` is reduced to `x / (1 - y + y)`:\n```\nexample (x y z : ℚ) (hy : 1 - y ≠ 0) :\n    ⌊x / (1 - y) / (1 + y / (1 - y))⌋ < 3 := by\n  field_simp\n  -- new goal: `⊢ ⌊x / (1 - y + y)⌋ < 3`\n```\n\nThe `field_simp` tactic will also clear denominators in field *(in)equalities*, by\ncross-multiplying. For example, `field_simp` will clear the `x` denominators in the following\nequation:\n```\nexample {K : Type*} [Field K] {x : K} (hx0 : x ≠ 0) :\n    (x + 1 / x) ^ 2 + (x + 1 / x) = 1 := by\n  field_simp\n  -- new goal: `⊢ (x ^ 2 + 1) * (x ^ 2 + 1 + x) = x ^ 2`\n```\n\nA very common pattern is `field_simp; ring` (clear denominators, then the resulting goal is\nsolvable by the axioms of a commutative ring). The finishing tactic `field` is a shorthand for this\npattern.\n\nCancelling and combining denominators will generally require checking \"nonzeroness\"/\"positivity\"\nside conditions. The `field_simp` tactic attempts to discharge these, and will omit such steps if it\ncannot discharge the corresponding side conditions. The discharger will try, among other things,\n`positivity` and `norm_num`, and will also use any nonzeroness/positivity proofs included explicitly\n(e.g. `field_simp [hx]`). If your expression is not completely reduced by `field_simp`, check the\ndenominators of the resulting expression and provide proofs that they are nonzero/positive to enable\nfurther progress.\n","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.fieldSimp","kind":"def","line":671,"name":"Mathlib.Tactic.FieldSimp.fieldSimp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L671-L711"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.parseDischarger\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">parseDischarger</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">d</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Tactic.discharger</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Tactic.simpArgs</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <span class=\"fn\">({<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>} → <span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>) → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span></span></span>)</span></span></div></div>","info":{"doc":"If the user provided a discharger, elaborate it. If not, we will use the `field_simp` default\ndischarger, which (among other things) includes a simp-run for the specified argument list, so we\nelaborate those arguments. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.parseDischarger","kind":"def","line":652,"name":"Mathlib.Tactic.FieldSimp.parseDischarger","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L652-L669"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceProp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">reduceProp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch</span> : <span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>} → <span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>) → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>","info":{"doc":"Given an (in)equality `a = b` (respectively, `a ≤ b`, `a < b`), cancel nonzero (resp. positive)\nfactors to construct a new (in)equality which is logically equivalent to `a = b` (respectively,\n`a ≤ b`, `a < b`). ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceProp","kind":"def","line":614,"name":"Mathlib.Tactic.FieldSimp.reduceProp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L614-L646"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">reduceExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch</span> : <span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>} → <span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>) → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>","info":{"doc":"Given `x` in a commutative group-with-zero, construct a new expression in the standard form\n*** / *** (all denominators at the end) which is equal to `x`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceExpr","kind":"def","line":595,"name":"Mathlib.Tactic.FieldSimp.reduceExpr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L595-L612"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceLtQ\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">reduceLtQ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch</span> : <span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>} → <span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>) → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero\">CommGroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM'</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/PartialOrder.html#PartialOrder\">PartialOrder</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM''</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#PosMulStrictMono\">PosMulStrictMono</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM'''</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#PosMulReflectLT\">PosMulReflectLT</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM''''</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Order/ZeroLEOne.html#ZeroLEOneClass\">ZeroLEOneClass</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">((<span class=\"fn\">f₁</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>) × <span class=\"fn\">(<span class=\"fn\">f₂</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>) × <span class=\"fn\">Q((<span class=\"fn\">«$e₁»</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">«$e₂»</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> (<span class=\"fn\">«$f₁»</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">«$f₂»</span>))</span></span>)</span></span></div></div>","info":{"doc":"Given `e₁` and `e₂`, cancel positive factors to construct a new inequality which is logically\nequivalent to `e₁ < e₂`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceLtQ","kind":"def","line":577,"name":"Mathlib.Tactic.FieldSimp.reduceLtQ","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L577-L593"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceLeQ\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">reduceLeQ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch</span> : <span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>} → <span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>) → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero\">CommGroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM'</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/PartialOrder.html#PartialOrder\">PartialOrder</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM''</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#PosMulStrictMono\">PosMulStrictMono</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM'''</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#PosMulReflectLE\">PosMulReflectLE</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM''''</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Order/ZeroLEOne.html#ZeroLEOneClass\">ZeroLEOneClass</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">((<span class=\"fn\">f₁</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>) × <span class=\"fn\">(<span class=\"fn\">f₂</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>) × <span class=\"fn\">Q((<span class=\"fn\">«$e₁»</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">«$e₂»</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> (<span class=\"fn\">«$f₁»</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">«$f₂»</span>))</span></span>)</span></span></div></div>","info":{"doc":"Given `e₁` and `e₂`, cancel positive factors to construct a new inequality which is logically\nequivalent to `e₁ ≤ e₂`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceLeQ","kind":"def","line":559,"name":"Mathlib.Tactic.FieldSimp.reduceLeQ","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L559-L575"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceEqQ\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">reduceEqQ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch</span> : <span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>} → <span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>) → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero\">CommGroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">((<span class=\"fn\">f₁</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>) × <span class=\"fn\">(<span class=\"fn\">f₂</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>) × <span class=\"fn\">Q((<span class=\"fn\">«$e₁»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$e₂»</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> (<span class=\"fn\">«$f₁»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$f₂»</span>))</span></span>)</span></span></div></div>","info":{"doc":"Given `e₁` and `e₂`, cancel nonzero factors to construct a new equality which is logically\nequivalent to `e₁ = e₂`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceEqQ","kind":"def","line":544,"name":"Mathlib.Tactic.FieldSimp.reduceEqQ","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L544-L557"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceExprQ\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">reduceExprQ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch</span> : <span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>} → <span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>) → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero\">CommGroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">((<span class=\"fn\">x'</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>) × <span class=\"fn\">Q(<span class=\"fn\">«$x»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$x'»</span>)</span>)</span></span></div></div>","info":{"doc":"Given `x` in a commutative group-with-zero, construct a new expression in the standard form\n*** / *** (all denominators at the end) which is equal to `x`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceExprQ","kind":"def","line":534,"name":"Mathlib.Tactic.FieldSimp.reduceExprQ","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L534-L542"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.normalize\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">normalize</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch</span> : <span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>} → <span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>) → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero\">CommGroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a>\n  <span class=\"fn\">((<span class=\"fn\">y</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>) ×\n    <span class=\"fn\">((<span class=\"fn\">g</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.Sign\">Sign</a> <span class=\"fn\">M</span></span>) ×\n        <span class=\"fn\">have <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">g</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.Sign.expr\">expr</a></span> <span class=\"fn\">y</span></span>;\n        <span class=\"fn\">Q(<span class=\"fn\">«$x»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$a»</span>)</span></span>)</span> <a href=\"./Init/Prelude.html#Prod\">×</a>       <span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>) ×\n        <span class=\"fn\">have <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n        <span class=\"fn\">Q(<span class=\"fn\">«$y»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">«$a»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span>)</span></span></span>)</span></span></div></div>","info":{"doc":"The main algorithm behind the `field_simp` tactic: partially-normalizing an\nexpression in a field `M` into the form x1 ^ c1 * x2 ^ c2 * ... x_k ^ c_k,\nwhere x1, x2, ... are distinct atoms in `M`, and c1, c2, ... are integers. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.normalize","kind":"opaque","line":415,"name":"Mathlib.Tactic.FieldSimp.normalize","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L415-L532"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.gcd\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">qNF</span>.<span class=\"name\">gcd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero\">CommGroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l₁ </span><span class=\"fn\">l₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch</span> : <span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>} → <span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>) → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cond</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition\">DenomCondition</a> <span class=\"fn\">q(<a href=\"./Init/Prelude.html#inferInstance\">inferInstance</a>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a>\n  <span class=\"fn\">((<span class=\"fn\">L</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>) ×\n    <span class=\"fn\">(<span class=\"fn\">l₁'</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>) ×\n      <span class=\"fn\">(<span class=\"fn\">l₂'</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>) ×\n        <span class=\"fn\">(have <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n          <span class=\"fn\">have <span class=\"fn\">a_1</span> := <span class=\"fn\"><span class=\"fn\">l₁'</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n          <span class=\"fn\">have <span class=\"fn\">a_2</span> := <span class=\"fn\"><span class=\"fn\">L</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n          <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$a_2»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\"><span class=\"fn\">«$a_1»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">«$a»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span>)</span></span></span>)</span> <a href=\"./Init/Prelude.html#Prod\">×</a>           <span class=\"fn\">(have <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n            <span class=\"fn\">have <span class=\"fn\">a_1</span> := <span class=\"fn\"><span class=\"fn\">l₂'</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n            <span class=\"fn\">have <span class=\"fn\">a_2</span> := <span class=\"fn\"><span class=\"fn\">L</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n            <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$a_2»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\"><span class=\"fn\">«$a_1»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">«$a»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span>)</span></span></span>)</span> <a href=\"./Init/Prelude.html#Prod\">×</a>             <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof\">DenomCondition.proof</a> <span class=\"fn\">L</span> <span class=\"fn\">cond</span></span></span></span>)</span></span></div></div>","info":{"doc":"Extract a common factor `L` of two products-of-powers `l₁` and `l₂` in `M`, in the sense that\nboth `l₁` and `l₂` are quotients by `L` of products of *positive* powers.\n\nThe variable `cond` specifies whether we extract a *certified nonzero[/positive]* (and therefore\npotentially smaller) common factor. If so, the metaprogram returns a \"proof\" that this common factor\nis nonzero/positive, i.e. an expression `Q(NF.eval $(L.toNF) ≠ 0)` / `Q(0 < NF.eval $(L.toNF))`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.gcd","kind":"opaque","line":322,"name":"Mathlib.Tactic.FieldSimp.qNF.gcd","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L322-L409"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">mkDenomConditionProofSucc'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero\">CommGroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch</span> : <span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>} → <span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>) → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span></span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">cond</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition\">DenomCondition</a> <span class=\"fn\">q(<a href=\"./Init/Prelude.html#inferInstance\">inferInstance</a>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">L</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hL</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof\">DenomCondition.proof</a> <span class=\"fn\">L</span> <span class=\"fn\">cond</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof\">DenomCondition.proof</a> (<a href=\"./Init/Prelude.html#Prod.mk\">(</a><a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">r</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">e</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">i</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Init/Prelude.html#List.cons\">::</a> <span class=\"fn\">L</span>) <span class=\"fn\">cond</span>)</span></span></div></div>","info":{"doc":"Given a proof of the nonzeroness, strict positivity, etc. (as specified by the value of\n`DenomCondition`) of a field-simp-normal-form expression `L` (a product of powers of atoms),\nconstruct a corresponding proof for `((r, e), i) :: L`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc'","kind":"def","line":301,"name":"Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L301-L318"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">mkDenomConditionProofSucc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero\">CommGroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch</span> : <span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>} → <span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>) → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span></span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">cond</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition\">DenomCondition</a> <span class=\"fn\">q(<a href=\"./Init/Prelude.html#inferInstance\">inferInstance</a>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">L</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hL</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof\">DenomCondition.proof</a> <span class=\"fn\">L</span> <span class=\"fn\">cond</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<span class=\"fn\">Q(<span class=\"fn\">«$e»</span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">0</span>)</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof\">DenomCondition.proof</a> (<a href=\"./Init/Prelude.html#Prod.mk\">(</a><a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">r</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">e</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">i</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Init/Prelude.html#List.cons\">::</a> <span class=\"fn\">L</span>) <span class=\"fn\">cond</span></span>)</span></div></div>","info":{"doc":"Given a proof of the nonzeroness, strict positivity, etc. (as specified by the value of\n`DenomCondition`) of a field-simp-normal-form expression `L` (a product of powers of atoms),\nconstruct a corresponding proof for `((r, e), i) :: L`.\n\nIn this version we also expose the proof of nonzeroness of `e`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc","kind":"def","line":279,"name":"Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L279-L299"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proofZero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">DenomCondition</span>.<span class=\"name\">proofZero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero\">CommGroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cond</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition\">DenomCondition</a> <span class=\"fn\">q(<a href=\"./Init/Prelude.html#inferInstance\">inferInstance</a>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof\">proof</a> <a href=\"./Init/Prelude.html#List.nil\">[</a><a href=\"./Init/Prelude.html#List.nil\">]</a> <span class=\"fn\">cond</span></span></div></div>","info":{"doc":"The empty field-simp-normal-form expression `[]` (representing `1` as an empty product of powers\nof atoms) can be proved to be nonzero, strict positivity, etc., as needed, as specified by the\nvalue of `DenomCondition`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proofZero","kind":"def","line":268,"name":"Mathlib.Tactic.FieldSimp.DenomCondition.proofZero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L268-L275"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">DenomCondition</span>.<span class=\"name\">proof</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#GroupWithZero\">GroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">L</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition\">DenomCondition</a> <span class=\"fn\">iM</span></span> → <a href=\"./foundational_types.html\">Type</a></span></div></div>","info":{"doc":"Given a field-simp-normal-form expression `L` (a product of powers of atoms), a proof (according\nto the value of `DenomCondition`) of that expression's nonzeroness, strict positivity, etc. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof","kind":"def","line":261,"name":"Mathlib.Tactic.FieldSimp.DenomCondition.proof","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L261-L266"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.positive\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">DenomCondition</span>.<span class=\"name\">positive</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#GroupWithZero\">GroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM'</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/PartialOrder.html#PartialOrder\">PartialOrder</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM''</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#PosMulStrictMono\">PosMulStrictMono</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM'''</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#PosMulReflectLT\">PosMulReflectLT</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM''''</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Order/ZeroLEOne.html#ZeroLEOneClass\">ZeroLEOneClass</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition\">DenomCondition</a> <span class=\"fn\">iM</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.positive","kind":"ctor","line":256,"name":"Mathlib.Tactic.FieldSimp.DenomCondition.positive","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L256-L257"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.nonzero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">DenomCondition</span>.<span class=\"name\">nonzero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#GroupWithZero\">GroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition\">DenomCondition</a> <span class=\"fn\">iM</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.nonzero","kind":"ctor","line":255,"name":"Mathlib.Tactic.FieldSimp.DenomCondition.nonzero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L255-L255"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.none\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">DenomCondition</span>.<span class=\"name\">none</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#GroupWithZero\">GroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition\">DenomCondition</a> <span class=\"fn\">iM</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.none","kind":"ctor","line":254,"name":"Mathlib.Tactic.FieldSimp.DenomCondition.none","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L254-L254"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">DenomCondition</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#GroupWithZero\">GroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Constraints on denominators which may need to be considered in `field_simp`: no condition,\nnonzeroness, or strict positivity. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition","kind":"inductive","line":251,"name":"Mathlib.Tactic.FieldSimp.DenomCondition","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L251-L257"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mkDivProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">qNF</span>.<span class=\"name\">mkDivProof</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero\">CommGroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l₁ </span><span class=\"fn\">l₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">have <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.div\">div</a></span> <span class=\"fn\">l₂</span>)</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n<span class=\"fn\">have <span class=\"fn\">a_1</span> := <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n<span class=\"fn\">have <span class=\"fn\">a_2</span> := <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n<span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$a_2»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HDiv.hDiv\">/</a> <span class=\"fn\"><span class=\"fn\">«$a_1»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">«$a»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span>)</span></span></span></span></div></div>","info":{"doc":"Given two terms `l₁`, `l₂` of type `qNF M`, i.e. lists of `(ℤ × Q($M)) × ℕ`s (an integer, an\n`Expr` and a natural number), recursively construct a proof that in the field `$M`, the quotient\nof the \"multiplicative linear combinations\" represented by `l₁` and `l₂` is the multiplicative\nlinear combination represented by `FieldSimp.qNF.div l₁ l₁`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mkDivProof","kind":"def","line":229,"name":"Mathlib.Tactic.FieldSimp.qNF.mkDivProof","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L229-L247"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.div\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">qNF</span>.<span class=\"name\">div</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span></span></div></div>","info":{"doc":"Given two terms `l₁`, `l₂` of type `qNF M`, i.e. lists of `(ℤ × Q($M)) × ℕ`s (an integer, an\n`Expr` and a natural number), construct another such term `l`, which will have the property that in\nthe field `$M`, the quotient of the \"multiplicative linear combinations\" represented by `l₁` and\n`l₂` is the multiplicative linear combination represented by `l`.\n\nThe construction assumes, to be valid, that the lists `l₁` and `l₂` are in strictly decreasing order\nby `ℕ`-component, and that if pairs `(a₁, x₁)` and `(a₂, x₂)` appear in `l₁`, `l₂` respectively with\nthe same `ℕ`-component `k`, then the expressions `x₁` and `x₂` are equal.\n\nThe construction is as follows: merge the first list and the negation of the second list, except\nthat if pairs `(a₁, x₁)` and `(a₂, x₂)` appear in `l₁`, `l₂` respectively with the same\n`ℕ`-component `k`, then contribute a term `(a₁ - a₂, x₁)` to the output list with `ℕ`-component `k`.\n","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.div","kind":"def","line":205,"name":"Mathlib.Tactic.FieldSimp.qNF.div","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L205-L227"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mkMulProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">qNF</span>.<span class=\"name\">mkMulProof</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero\">CommGroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l₁ </span><span class=\"fn\">l₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">have <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mul\">mul</a></span> <span class=\"fn\">l₂</span>)</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n<span class=\"fn\">have <span class=\"fn\">a_1</span> := <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n<span class=\"fn\">have <span class=\"fn\">a_2</span> := <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n<span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$a_2»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\"><span class=\"fn\">«$a_1»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">«$a»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span>)</span></span></span></span></div></div>","info":{"doc":"Given two terms `l₁`, `l₂` of type `qNF M`, i.e. lists of `(ℤ × Q($M)) × ℕ`s (an integer, an\n`Expr` and a natural number), recursively construct a proof that in the field `$M`, the product of\nthe \"multiplicative linear combinations\" represented by `l₁` and `l₂` is the multiplicative linear\ncombination represented by `FieldSimp.qNF.mul l₁ l₁`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mkMulProof","kind":"def","line":185,"name":"Mathlib.Tactic.FieldSimp.qNF.mkMulProof","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L185-L203"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">qNF</span>.<span class=\"name\">mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">q(<span class=\"fn\">«$M»</span>)</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">q(<span class=\"fn\">«$M»</span>)</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">q(<span class=\"fn\">«$M»</span>)</span></span></span></div></div>","info":{"doc":"Given two terms `l₁`, `l₂` of type `qNF M`, i.e. lists of `(ℤ × Q($M)) × ℕ`s (an integer, an\n`Expr` and a natural number), construct another such term `l`, which will have the property that in\nthe field `$M`, the product of the \"multiplicative linear combinations\" represented by `l₁` and\n`l₂` is the multiplicative linear combination represented by `l`.\n\nThe construction assumes, to be valid, that the lists `l₁` and `l₂` are in strictly decreasing order\nby `ℕ`-component, and that if pairs `(a₁, x₁)` and `(a₂, x₂)` appear in `l₁`, `l₂` respectively with\nthe same `ℕ`-component `k`, then the expressions `x₁` and `x₂` are equal.\n\nThe construction is as follows: merge the two lists, except that if pairs `(a₁, x₁)` and `(a₂, x₂)`\nappear in `l₁`, `l₂` respectively with the same `ℕ`-component `k`, then contribute a term\n`(a₁ + a₂, x₁)` to the output list with `ℕ`-component `k`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mul","kind":"def","line":160,"name":"Mathlib.Tactic.FieldSimp.qNF.mul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L160-L183"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.evalPretty\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">qNF</span>.<span class=\"name\">evalPretty</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero\">CommGroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a>\n  <span class=\"fn\">((<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>) ×\n    <span class=\"fn\">have <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n    <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$a»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$e»</span>)</span></span>)</span></span></div></div>","info":{"doc":"Build a transparent expression for the product of powers represented by `l : qNF M`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.evalPretty","kind":"def","line":145,"name":"Mathlib.Tactic.FieldSimp.qNF.evalPretty","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L145-L158"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.split\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">qNF</span>.<span class=\"name\">split</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero\">CommGroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a>\n  <span class=\"fn\">((<span class=\"fn\">l_n</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>) ×\n    <span class=\"fn\">(<span class=\"fn\">l_d</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>) ×\n      <span class=\"fn\">have <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\">l_d</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n      <span class=\"fn\">have <span class=\"fn\">a_1</span> := <span class=\"fn\"><span class=\"fn\">l_n</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n      <span class=\"fn\">have <span class=\"fn\">a_2</span> := <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n      <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$a_2»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">«$a_1»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HDiv.hDiv\">/</a> <span class=\"fn\"><span class=\"fn\">«$a»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span>)</span></span></span></span></span>)</span></span></div></div>","info":{"doc":"Given a product of powers, split as a quotient: the positive powers divided by (the negations\nof) the negative powers. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.split","kind":"def","line":114,"name":"Mathlib.Tactic.FieldSimp.qNF.split","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L114-L129"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.removeZeros\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">qNF</span>.<span class=\"name\">removeZeros</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch</span> : <span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>} → <span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>) → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero\">CommGroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a>\n  <span class=\"fn\">((<span class=\"fn\">l'</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>) ×\n    <span class=\"fn\">have <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\">l'</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n    <span class=\"fn\">have <span class=\"fn\">a_1</span> := <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n    <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$a_1»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">«$a»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span>)</span></span></span>)</span></span></div></div>","info":{"doc":"Given `l : qNF M`, obtain `l' : qNF M` by removing all `l`'s exponent-zero entries where the\ncorresponding atom can be proved nonzero, and construct a proof that their associated expressions\nare equal. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.removeZeros","kind":"def","line":97,"name":"Mathlib.Tactic.FieldSimp.qNF.removeZeros","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L97-L112"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.tryClearZero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">qNF</span>.<span class=\"name\">tryClearZero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch</span> : <span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>} → <span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>) → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero\">CommGroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a>\n  <span class=\"fn\">((<span class=\"fn\">l'</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>) ×\n    <span class=\"fn\">have <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\">l'</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n    <span class=\"fn\">have <span class=\"fn\">a_1</span> := <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a> (<a href=\"./Init/Prelude.html#Prod.mk\">(</a><a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">r</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">x</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">i</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Init/Prelude.html#List.cons\">::</a> <span class=\"fn\">l</span>)</span>;\n    <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$a_1»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">«$a»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span>)</span></span></span>)</span></span></div></div>","info":{"doc":"Try to drop an expression `zpow' x r` from the beginning of a product. If `r ≠ 0` this of course\ncan't be done. If `r = 0`, then `zpow' x r` is equal to `x / x`, so it can be simplified to 1 (hence\ndropped from the beginning of the product) if we can find a proof that `x ≠ 0`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.tryClearZero","kind":"def","line":81,"name":"Mathlib.Tactic.FieldSimp.qNF.tryClearZero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L81-L95"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.evalPrettyMonomial\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">qNF</span>.<span class=\"name\">evalPrettyMonomial</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#GroupWithZero\">GroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">((<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>) × <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.zpow'\">zpow'</a> <span class=\"fn\">«$x»</span> <span class=\"fn\">«$r»</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$e»</span>)</span>)</span></span></div></div>","info":{"doc":"Build a transparent expression for the product of powers represented by `l : qNF M`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.evalPrettyMonomial","kind":"def","line":67,"name":"Mathlib.Tactic.FieldSimp.qNF.evalPrettyMonomial","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L67-L79"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.onExponent\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">qNF</span>.<span class=\"name\">onExponent</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a> → <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span></div></div>","info":{"doc":"Given `l` of type `qNF M`, i.e. a list of `(ℤ × Q($M)) × ℕ`s (two `Expr`s and a natural\nnumber), apply an expression representing a function with domain `ℤ` to each of the `ℤ`\ncomponents. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.onExponent","kind":"def","line":61,"name":"Mathlib.Tactic.FieldSimp.qNF.onExponent","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L61-L65"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">qNF</span>.<span class=\"name\">toNF</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">q(<span class=\"fn\">«$M»</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF\">NF</a> <span class=\"fn\">«$M»</span></span>)</span></div></div>","info":{"doc":"Given `l` of type `qNF M`, i.e. a list of `(ℤ × Q($M)) × ℕ`s (two `Expr`s and a natural\nnumber), build an `Expr` representing an object of type `NF M` (i.e. `List (ℤ × M)`) in the\nin the obvious way: by forgetting the natural numbers and gluing together the integers and `Expr`s.\n","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF","kind":"def","line":52,"name":"Mathlib.Tactic.FieldSimp.qNF.toNF","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L52-L59"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">qNF</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Basic meta-code \"normal form\" object of the `field_simp` tactic: a type synonym\nfor a list of ordered triples comprising an expression representing a term of a type `M` (where\ntypically `M` is a field), together with an integer \"power\" and a natural number \"index\".\n\nThe natural number represents the index of the `M` term in the `AtomM` monad: this is not enforced,\nbut is sometimes assumed in operations.  Thus when items `((a₁, x₁), k)` and `((a₂, x₂), k)`\nappear in two different `FieldSimp.qNF` objects (i.e. with the same `ℕ`-index `k`), it is expected\nthat the expressions `x₁` and `x₂` are the same.  It is also expected that the items in a\n`FieldSimp.qNF` list are in strictly decreasing order by natural-number index.\n\nBy forgetting the natural number indices, an expression representing a `Mathlib.Tactic.FieldSimp.NF`\nobject can be built from a `FieldSimp.qNF` object; this construction is provided as\n`Mathlib.Tactic.FieldSimp.qNF.toNF`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF","kind":"def","line":35,"name":"Mathlib.Tactic.FieldSimp.qNF","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/FieldSimp.lean#L35-L48"}}],"imports":["Init","Mathlib.Data.Ineq","Mathlib.Util.AtLocation","Mathlib.Data.Ineq","Mathlib.Tactic.FieldSimp.Attr","Mathlib.Tactic.FieldSimp.Discharger","Mathlib.Tactic.FieldSimp.Lemmas","Mathlib.Util.AtomM.Recurse","Mathlib.Util.SynthesizeUsing"],"instances":[],"name":"Mathlib.Tactic.FieldSimp"}