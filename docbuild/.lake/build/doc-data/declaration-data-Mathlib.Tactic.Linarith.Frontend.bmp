{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.elabLinarithConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">elabLinarithConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig\">Linarith.LinarithConfig</a></span></span></div></div>","info":{"doc":"Allow elaboration of `LinarithConfig` arguments to tactics.\n","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.elabLinarithConfig","kind":"def","line":507,"name":"Mathlib.Tactic.elabLinarithConfig","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Frontend.lean#L507-L510"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.tacticNlinarith!_\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticNlinarith!_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"An extension of `linarith` with some preprocessing to allow it to solve some nonlinear arithmetic\nproblems. (Based on Coq's `nra` tactic.) See `linarith` for the available syntax of options,\nwhich are inherited by `nlinarith`; that is, `nlinarith!` and `nlinarith only [h1, h2]` all work as\nin `linarith`. The preprocessing is as follows:\n\n* For every subterm `a ^ 2` or `a * a` in a hypothesis or the goal,\n  the assumption `0 ≤ a ^ 2` or `0 ≤ a * a` is added to the context.\n* For every pair of hypotheses `a1 R1 b1`, `a2 R2 b2` in the context, `R1, R2 ∈ {<, ≤, =}`,\n  the assumption `0 R' (b1 - a1) * (b2 - a2)` is added to the context (non-recursively),\n  where `R ∈ {<, ≤, =}` is the appropriate comparison derived from `R1, R2`.\n","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.tacticNlinarith!_","kind":"def","line":504,"name":"Mathlib.Tactic.tacticNlinarith!_","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Frontend.lean#L504-L505"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.nlinarith\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">nlinarith</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"An extension of `linarith` with some preprocessing to allow it to solve some nonlinear arithmetic\nproblems. (Based on Coq's `nra` tactic.) See `linarith` for the available syntax of options,\nwhich are inherited by `nlinarith`; that is, `nlinarith!` and `nlinarith only [h1, h2]` all work as\nin `linarith`. The preprocessing is as follows:\n\n* For every subterm `a ^ 2` or `a * a` in a hypothesis or the goal,\n  the assumption `0 ≤ a ^ 2` or `0 ≤ a * a` is added to the context.\n* For every pair of hypotheses `a1 R1 b1`, `a2 R2 b2` in the context, `R1, R2 ∈ {<, ≤, =}`,\n  the assumption `0 R' (b1 - a1) * (b2 - a2)` is added to the context (non-recursively),\n  where `R ∈ {<, ≤, =}` is the appropriate comparison derived from `R1, R2`.\n","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.nlinarith","kind":"def","line":491,"name":"Mathlib.Tactic.nlinarith","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Frontend.lean#L491-L503"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.tacticLinarith?!_\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticLinarith?!_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`linarith?` behaves like `linarith` but, on success, it prints a suggestion of\nthe form `linarith only [...]` listing a minimized set of hypotheses used in the\nfinal proof.  Use `linarith?!` for the higher-reducibility variant and set the\n`minimize` flag in the configuration to control whether greedy minimization is\nperformed.\n","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.tacticLinarith?!_","kind":"def","line":488,"name":"Mathlib.Tactic.tacticLinarith?!_","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Frontend.lean#L488-L489"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.tacticLinarith!_\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticLinarith!_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`linarith` attempts to find a contradiction between hypotheses that are linear (in)equalities.\nEquivalently, it can prove a linear inequality by assuming its negation and proving `False`.\n\nIn theory, `linarith` should prove any goal that is true in the theory of linear arithmetic over\nthe rationals. While there is some special handling for non-dense orders like `Nat` and `Int`,\nthis tactic is not complete for these theories and will not prove every true goal. It will solve\ngoals over arbitrary types that instantiate `CommRing`, `LinearOrder` and `IsStrictOrderedRing`.\n\nAn example:\n```lean\nexample (x y z : ℚ) (h1 : 2*x < 3*y) (h2 : -4*x + 2*z < 0)\n        (h3 : 12*y - 4* z < 0) : False := by\n  linarith\n```\n\n`linarith` will use all appropriate hypotheses and the negation of the goal, if applicable.\nDisequality hypotheses require case splitting and are not normally considered\n(see the `splitNe` option below).\n\n`linarith [t1, t2, t3]` will additionally use proof terms `t1, t2, t3`.\n\n`linarith only [h1, h2, h3, t1, t2, t3]` will use only the goal (if relevant), local hypotheses\n`h1`, `h2`, `h3`, and proofs `t1`, `t2`, `t3`. It will ignore the rest of the local context.\n\n`linarith!` will use a stronger reducibility setting to try to identify atoms. For example,\n```lean\nexample (x : ℚ) : id x ≥ x := by\n  linarith\n```\nwill fail, because `linarith` will not identify `x` and `id x`. `linarith!` will.\nThis can sometimes be expensive.\n\n`linarith (config := { .. })` takes a config object with five\noptional arguments:\n* `discharger` specifies a tactic to be used for reducing an algebraic equation in the\n  proof stage. The default is `ring`. Other options include `simp` for basic\n  problems.\n* `transparency` controls how hard `linarith` will try to match atoms to each other. By default\n  it will only unfold `reducible` definitions.\n* If `splitHypotheses` is true, `linarith` will split conjunctions in the context into separate\n  hypotheses.\n* If `splitNe` is `true`, `linarith` will case split on disequality hypotheses.\n  For a given `x ≠ y` hypothesis, `linarith` is run with both `x < y` and `x > y`,\n  and so this runs linarith exponentially many times with respect to the number of\n  disequality hypotheses. (`false` by default.)\n* If `exfalso` is `false`, `linarith` will fail when the goal is neither an inequality nor `False`.\n  (`true` by default.)\n* If `minimize` is `false`, `linarith?` will report all hypotheses appearing in its initial\n  proof without attempting to drop redundancies. (`true` by default.)\n* `restrict_type` (not yet implemented in mathlib4)\n  will only use hypotheses that are inequalities over `tp`. This is useful\n  if you have e.g. both integer- and rational-valued inequalities in the local context, which can\n  sometimes confuse the tactic.\n\nA variant, `nlinarith`, does some basic preprocessing to handle some nonlinear goals.\n\nThe option `set_option trace.linarith true` will trace certain intermediate stages of the `linarith`\nroutine.\n","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.tacticLinarith!_","kind":"def","line":486,"name":"Mathlib.Tactic.tacticLinarith!_","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Frontend.lean#L486-L487"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.linarith?\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">linarith?</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`linarith?` behaves like `linarith` but, on success, it prints a suggestion of\nthe form `linarith only [...]` listing a minimized set of hypotheses used in the\nfinal proof.  Use `linarith?!` for the higher-reducibility variant and set the\n`minimize` flag in the configuration to control whether greedy minimization is\nperformed.\n","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.linarith?","kind":"def","line":477,"name":"Mathlib.Tactic.linarith?","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Frontend.lean#L477-L484"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.linarith\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">linarith</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`linarith` attempts to find a contradiction between hypotheses that are linear (in)equalities.\nEquivalently, it can prove a linear inequality by assuming its negation and proving `False`.\n\nIn theory, `linarith` should prove any goal that is true in the theory of linear arithmetic over\nthe rationals. While there is some special handling for non-dense orders like `Nat` and `Int`,\nthis tactic is not complete for these theories and will not prove every true goal. It will solve\ngoals over arbitrary types that instantiate `CommRing`, `LinearOrder` and `IsStrictOrderedRing`.\n\nAn example:\n```lean\nexample (x y z : ℚ) (h1 : 2*x < 3*y) (h2 : -4*x + 2*z < 0)\n        (h3 : 12*y - 4* z < 0) : False := by\n  linarith\n```\n\n`linarith` will use all appropriate hypotheses and the negation of the goal, if applicable.\nDisequality hypotheses require case splitting and are not normally considered\n(see the `splitNe` option below).\n\n`linarith [t1, t2, t3]` will additionally use proof terms `t1, t2, t3`.\n\n`linarith only [h1, h2, h3, t1, t2, t3]` will use only the goal (if relevant), local hypotheses\n`h1`, `h2`, `h3`, and proofs `t1`, `t2`, `t3`. It will ignore the rest of the local context.\n\n`linarith!` will use a stronger reducibility setting to try to identify atoms. For example,\n```lean\nexample (x : ℚ) : id x ≥ x := by\n  linarith\n```\nwill fail, because `linarith` will not identify `x` and `id x`. `linarith!` will.\nThis can sometimes be expensive.\n\n`linarith (config := { .. })` takes a config object with five\noptional arguments:\n* `discharger` specifies a tactic to be used for reducing an algebraic equation in the\n  proof stage. The default is `ring`. Other options include `simp` for basic\n  problems.\n* `transparency` controls how hard `linarith` will try to match atoms to each other. By default\n  it will only unfold `reducible` definitions.\n* If `splitHypotheses` is true, `linarith` will split conjunctions in the context into separate\n  hypotheses.\n* If `splitNe` is `true`, `linarith` will case split on disequality hypotheses.\n  For a given `x ≠ y` hypothesis, `linarith` is run with both `x < y` and `x > y`,\n  and so this runs linarith exponentially many times with respect to the number of\n  disequality hypotheses. (`false` by default.)\n* If `exfalso` is `false`, `linarith` will fail when the goal is neither an inequality nor `False`.\n  (`true` by default.)\n* If `minimize` is `false`, `linarith?` will report all hypotheses appearing in its initial\n  proof without attempting to drop redundancies. (`true` by default.)\n* `restrict_type` (not yet implemented in mathlib4)\n  will only use hypotheses that are inequalities over `tp`. This is useful\n  if you have e.g. both integer- and rational-valued inequalities in the local context, which can\n  sometimes confuse the tactic.\n\nA variant, `nlinarith`, does some basic preprocessing to handle some nonlinear goals.\n\nThe option `set_option trace.linarith true` will trace certain intermediate stages of the `linarith`\nroutine.\n","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.linarith","kind":"def","line":415,"name":"Mathlib.Tactic.linarith","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Frontend.lean#L415-L475"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.linarithArgsRest\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">linarithArgsRest</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Syntax for the arguments of `linarith`, after the optional `!`. ","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.linarithArgsRest","kind":"def","line":412,"name":"Mathlib.Tactic.linarithArgsRest","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Frontend.lean#L412-L413"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.linarith\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">linarith</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">only_on</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hyps</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cfg</span> : <a href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig\">LinarithConfig</a> := <a href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig.mk\">{</a> <a href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig.mk\">}</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Run the core `linarith` procedure on the goal `g` using the hypotheses `hyps`.\nIf `only_on` is true, the search is restricted to `hyps`; otherwise all suitable\nlocal hypotheses are considered. This is the workhorse behind the user-facing\n`linarith` tactic.\n","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.linarith","kind":"def","line":396,"name":"Mathlib.Tactic.Linarith.linarith","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Frontend.lean#L396-L404"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.linarithUsedHyps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">linarithUsedHyps</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">only_on</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hyps</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cfg</span> : <a href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig\">LinarithConfig</a> := <a href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig.mk\">{</a> <a href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig.mk\">}</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"`linarithUsedHyps only_on hyps cfg g` runs `linarith` with the supplied hypotheses. It\nfails if the goal cannot be closed. When successful, it returns the subset of `hyps` that\nwere actually used (i.e. had a nonzero coefficient) in the final certificate.\n\n* `hyps` is a list of proofs of comparisons to include in the search.\n* If `only_on` is true, the search will be restricted to `hyps`. Otherwise it will use all\n  comparisons in the local context.\n* If `cfg.transparency := semireducible`,\n  it will unfold semireducible definitions when trying to match atomic expressions.\n","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.linarithUsedHyps","kind":"opaque","line":338,"name":"Mathlib.Tactic.Linarith.linarithUsedHyps","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Frontend.lean#L338-L394"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.runLinarith\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">runLinarith</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cfg</span> : <a href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig\">LinarithConfig</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prefType</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hyps</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span></div></div>","info":{"doc":"Given a list `hyps` of proofs of comparisons, `runLinarith cfg prefType g hyps` preprocesses\n`hyps` according to the list of preprocessors in `cfg`. This results in a list of branches\n(typically only one), each of which must succeed in order to close the goal.\n\nIn each branch, the hypotheses are partitioned by type and `linarith` is run on each class in\nturn; one of these must succeed in order for `linarith` to succeed on the branch. If `prefType`\nis provided, the corresponding class is tried first.\n\nOn success, the metavariable `g` is assigned and the function returns the indices of the\noriginal hypotheses that were used with nonzero coefficient in the final proof.\n","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.runLinarith","kind":"def","line":275,"name":"Mathlib.Tactic.Linarith.runLinarith","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Frontend.lean#L275-L325"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.findLinarithContradiction\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">findLinarithContradiction</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cfg</span> : <a href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig\">LinarithConfig</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ls</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></div></div>","info":{"doc":"Given a list `ls` of pairs `(α, L)` where each `L` is a list of indexed proofs of\ncomparisons over the type `α`, `findLinarithContradiction cfg g ls` tries each list in\nsuccession, invoking `linarith` until one produces a contradiction. It returns the\nresulting proof of `False` together with the indices of the hypotheses that had\nnonzero coefficients in the final certificate.\n","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.findLinarithContradiction","kind":"def","line":257,"name":"Mathlib.Tactic.Linarith.findLinarithContradiction","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Frontend.lean#L257-L273"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.partitionByTypeIdx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">partitionByTypeIdx</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.ExprMultiMap\">ExprMultiMap</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a>))</span></span></div></div>","info":{"doc":"`partitionByTypeIdx l` takes a list `l` of pairs `(h, i)` where `h` is a proof of a\ncomparison and `i` records the original position of `h`. The proofs are grouped by the\ntype of the variables appearing in the comparison, e.g. `(a : ℚ) < 1` and\n`(b : ℤ) > c` will be separated. The resulting map associates each type with the\nlist of `(h, i)` pairs over that type.\n","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.partitionByTypeIdx","kind":"def","line":247,"name":"Mathlib.Tactic.Linarith.partitionByTypeIdx","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Frontend.lean#L247-L255"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.ExprMultiMap.insert\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">ExprMultiMap</span>.<span class=\"name\">insert</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.ExprMultiMap\">ExprMultiMap</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">v</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.ExprMultiMap\">ExprMultiMap</a> <span class=\"fn\">α</span>)</span></span></div></div>","info":{"doc":"Insert a new value into the map at key `k`. This does a defeq check with all other keys\nin the map. ","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.ExprMultiMap.insert","kind":"def","line":238,"name":"Mathlib.Tactic.Linarith.ExprMultiMap.insert","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Frontend.lean#L238-L245"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.ExprMultiMap.find\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">ExprMultiMap</span>.<span class=\"name\">find</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.ExprMultiMap\">ExprMultiMap</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span>)</span></div></div>","info":{"doc":"Retrieves the list of values at a key, as well as the index of the key for later modification.\n(If the key is not in the map it returns `self.size` as the index.) ","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.ExprMultiMap.find","kind":"def","line":229,"name":"Mathlib.Tactic.Linarith.ExprMultiMap.find","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Frontend.lean#L229-L236"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.ExprMultiMap\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">ExprMultiMap</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u_1</div></div>","info":{"doc":"A map of keys to values, where the keys are `Expr` up to defeq and one key can be\nassociated to multiple values. ","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.ExprMultiMap","kind":"def","line":225,"name":"Mathlib.Tactic.Linarith.ExprMultiMap","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Frontend.lean#L225-L227"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.applyContrLemma\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">applyContrLemma</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></div></div>","info":{"doc":"`applyContrLemma` inspects the target to see if it can be moved to a hypothesis by negation.\nFor example, a goal `⊢ a ≤ b` can become `b < a ⊢ false`.\nIf this is the case, it applies the appropriate lemma and introduces the new hypothesis.\nIt returns the type of the terms in the comparison (e.g. the type of `a` and `b` above) and the\nnewly introduced local constant.\nOtherwise returns `none`.\n","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.applyContrLemma","kind":"def","line":209,"name":"Mathlib.Tactic.Linarith.applyContrLemma","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Frontend.lean#L209-L223"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.getContrLemma\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">getContrLemma</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></div></div>","info":{"doc":"If `e` is a comparison `a R b` or the negation of a comparison `¬ a R b`, found in the target,\n`getContrLemma e` returns the name of a lemma that will change the goal to an\nimplication, along with the type of `a` and `b`.\n\nFor example, if `e` is `(a : ℕ) < b`, returns ``(`lt_of_not_ge, ℕ)``.\n","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.getContrLemma","kind":"def","line":195,"name":"Mathlib.Tactic.Linarith.getContrLemma","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Frontend.lean#L195-L207"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig.updateReducibility\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">LinarithConfig</span>.<span class=\"name\">updateReducibility</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cfg</span> : <a href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig\">LinarithConfig</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">reduce_default</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig\">LinarithConfig</a></div></div>","info":{"doc":"`cfg.updateReducibility reduce_default` will change the transparency setting of `cfg` to\n`default` if `reduce_default` is true. In this case, it also sets the discharger to `ring!`,\nsince this is typically needed when using stronger unification.\n","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig.updateReducibility","kind":"def","line":180,"name":"Mathlib.Tactic.Linarith.LinarithConfig.updateReducibility","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Frontend.lean#L180-L189"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig.oracle\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">LinarithConfig</span>.<span class=\"name\">oracle</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig\">LinarithConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.CertificateOracle\">CertificateOracle</a></div></div>","info":{"doc":"Specify an oracle for identifying candidate contradictions.\n`.simplexAlgorithmSparse`, `.simplexAlgorithmSparse`, and `.fourierMotzkin` are available. ","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig.oracle","kind":"def","line":178,"name":"Mathlib.Tactic.Linarith.LinarithConfig.oracle","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Frontend.lean#L178-L178"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig.preprocessors\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">LinarithConfig</span>.<span class=\"name\">preprocessors</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig\">LinarithConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.GlobalBranchingPreprocessor\">GlobalBranchingPreprocessor</a></span></div></div>","info":{"doc":"Override the list of preprocessors. ","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig.preprocessors","kind":"def","line":175,"name":"Mathlib.Tactic.Linarith.LinarithConfig.preprocessors","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Frontend.lean#L175-L175"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig.minimize\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">LinarithConfig</span>.<span class=\"name\">minimize</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig\">LinarithConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"If true, `linarith?` attempts to greedily remove unused hypotheses from its\nsuggestion. ","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig.minimize","kind":"def","line":173,"name":"Mathlib.Tactic.Linarith.LinarithConfig.minimize","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Frontend.lean#L173-L173"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig.splitNe\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">LinarithConfig</span>.<span class=\"name\">splitNe</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig\">LinarithConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"Split `≠` in hypotheses, by branching in cases `<` and `>`. ","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig.splitNe","kind":"def","line":170,"name":"Mathlib.Tactic.Linarith.LinarithConfig.splitNe","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Frontend.lean#L170-L170"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig.splitHypotheses\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">LinarithConfig</span>.<span class=\"name\">splitHypotheses</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig\">LinarithConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"Split conjunctions in hypotheses. ","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig.splitHypotheses","kind":"def","line":168,"name":"Mathlib.Tactic.Linarith.LinarithConfig.splitHypotheses","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Frontend.lean#L168-L168"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig.transparency\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">LinarithConfig</span>.<span class=\"name\">transparency</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig\">LinarithConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a></div></div>","info":{"doc":"Transparency mode for identifying atomic expressions in comparisons. ","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig.transparency","kind":"def","line":166,"name":"Mathlib.Tactic.Linarith.LinarithConfig.transparency","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Frontend.lean#L166-L166"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig.exfalso\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">LinarithConfig</span>.<span class=\"name\">exfalso</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig\">LinarithConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"Prove goals which are not linear comparisons by first calling `exfalso`. ","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig.exfalso","kind":"def","line":164,"name":"Mathlib.Tactic.Linarith.LinarithConfig.exfalso","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Frontend.lean#L164-L164"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig.discharger\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">LinarithConfig</span>.<span class=\"name\">discharger</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig\">LinarithConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Discharger to prove that a candidate linear combination of hypothesis is zero. ","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig.discharger","kind":"def","line":157,"name":"Mathlib.Tactic.Linarith.LinarithConfig.discharger","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Frontend.lean#L157-L157"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">LinarithConfig</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">discharger</span> : <span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">exfalso</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">transparency</span> : <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">splitHypotheses </span><span class=\"fn\">splitNe </span><span class=\"fn\">minimize</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">preprocessors</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.GlobalBranchingPreprocessor\">GlobalBranchingPreprocessor</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">oracle</span> : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.CertificateOracle\">CertificateOracle</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig\">LinarithConfig</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig.mk","kind":"ctor","line":154,"name":"Mathlib.Tactic.Linarith.LinarithConfig.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Frontend.lean#L154-L154"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">LinarithConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"A configuration object for `linarith`. ","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.Linarith.LinarithConfig","kind":"structure","line":153,"name":"Mathlib.Tactic.Linarith.LinarithConfig","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Frontend.lean#L153-L178"}}],"imports":["Init","Mathlib.Control.Basic","Mathlib.Tactic.Linarith.Oracle.SimplexAlgorithm","Mathlib.Tactic.Linarith.Preprocessing","Mathlib.Tactic.Linarith.Verification","Mathlib.Tactic.Ring.Basic","Mathlib.Util.ElabWithoutMVars"],"instances":[],"name":"Mathlib.Tactic.Linarith.Frontend"}