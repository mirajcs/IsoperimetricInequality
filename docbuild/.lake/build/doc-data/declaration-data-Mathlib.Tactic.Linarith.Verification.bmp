{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.proveFalseByLinarith\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">proveFalseByLinarith</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">transparency</span> : <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">oracle</span> : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.CertificateOracle\">CertificateOracle</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">discharger</span> : <span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span></span></div></div>","info":{"doc":"`proveFalseByLinarith` is the main workhorse of `linarith`.\nGiven a list `l` of proofs of `tᵢ Rᵢ 0`,\nit tries to derive a contradiction from `l` and use this to produce a proof of `False`.\n\n`oracle : CertificateOracle` is used to search for a certificate of unsatisfiability.\n\nThe returned certificate is a map `m` from hypothesis indices to natural number coefficients.\nIf our set of hypotheses has the form `{tᵢ Rᵢ 0}`,\nthen the elimination process should have guaranteed that\n1.\\ `∑ (m i)*tᵢ = 0`,\nwith at least one `i` such that `m i > 0` and `Rᵢ` is `<`.\n\nWe have also that\n2.\\ `∑ (m i)*tᵢ < 0`,\nsince for each `i`, `(m i)*tᵢ ≤ 0` and at least one is strictly negative.\nSo we conclude a contradiction `0 < 0`.\n\nIt remains to produce proofs of (1) and (2). (1) is verified by calling the provided `discharger`\ntactic, which is typically `ring`. We prove (2) by folding over the set of hypotheses.\n\n`transparency : TransparencyMode` controls the transparency level with which atoms are identified.\n","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.proveFalseByLinarith","kind":"def","line":174,"name":"Mathlib.Tactic.Linarith.proveFalseByLinarith","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Verification.lean#L174-L259"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.proveEqZeroUsing\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">proveEqZeroUsing</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tac</span> : <span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"`proveEqZeroUsing tac e` tries to use `tac` to construct a proof of `e = 0`.\n","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.proveEqZeroUsing","kind":"def","line":164,"name":"Mathlib.Tactic.Linarith.proveEqZeroUsing","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Verification.lean#L164-L170"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.addNegEqProofsIdx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">addNegEqProofsIdx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a>))</span></span></span></div></div>","info":{"doc":"`addNegEqProofsIdx l` inspects a list `l` of pairs `(h, i)` where `h` proves\n`tᵢ Rᵢ 0` and `i` records the original index of the hypothesis. For each\nequality proof `t = 0` in the list, it appends a proof of `-t = 0` with the\nsame index `i`. All other entries are preserved.\n","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.addNegEqProofsIdx","kind":"def","line":146,"name":"Mathlib.Tactic.Linarith.addNegEqProofsIdx","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Verification.lean#L146-L162"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.mkNegOneLtZeroProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">mkNegOneLtZeroProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tp</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"`mkNegOneLtZeroProof tp` returns a proof of `-1 < 0`,\nwhere the numerals are natively of type `tp`.\n","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.mkNegOneLtZeroProof","kind":"def","line":138,"name":"Mathlib.Tactic.Linarith.mkNegOneLtZeroProof","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Verification.lean#L138-L144"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.typeOfIneqProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">typeOfIneqProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prf</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"If `prf` is a proof of `t R s`, `typeOfIneqProof prf` returns the type of `t`. ","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.typeOfIneqProof","kind":"def","line":133,"name":"Mathlib.Tactic.Linarith.typeOfIneqProof","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Verification.lean#L133-L136"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.leftOfIneqProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">leftOfIneqProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prf</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"If `prf` is a proof of `t R s`, `leftOfIneqProof prf` returns `t`. ","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.leftOfIneqProof","kind":"def","line":128,"name":"Mathlib.Tactic.Linarith.leftOfIneqProof","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Verification.lean#L128-L131"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.mkLTZeroProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">mkLTZeroProof</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span></div></div>","info":{"doc":"`mkLTZeroProof coeffs pfs` takes a list of proofs of the form `tᵢ Rᵢ 0`,\npaired with coefficients `cᵢ`.\nIt produces a proof that `∑cᵢ * tᵢ R 0`, where `R` is as strong as possible.\n","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.mkLTZeroProof","kind":"def","line":103,"name":"Mathlib.Tactic.Linarith.mkLTZeroProof","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Verification.lean#L103-L126"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.addIneq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">addIneq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ineq.html#Mathlib.Ineq\">Ineq</a> → <a href=\"./Mathlib/Data/Ineq.html#Mathlib.Ineq\">Ineq</a> → <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Data/Ineq.html#Mathlib.Ineq\">Ineq</a></span></div></div>","info":{"doc":"If our goal is to add together two inequalities `t1 R1 0` and `t2 R2 0`,\n`addIneq R1 R2` produces the strength of the inequality in the sum `R`,\nalong with the name of a lemma to apply in order to conclude `t1 + t2 R 0`.\n","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.addIneq","kind":"def","line":87,"name":"Mathlib.Tactic.Linarith.addIneq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Verification.lean#L87-L101"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.addExprs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">addExprs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span></div></div>","info":{"doc":"`addExprs L` creates an `Expr` representing the sum of the elements of `L`, associated left. ","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.addExprs","kind":"def","line":78,"name":"Mathlib.Tactic.Linarith.addExprs","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Verification.lean#L78-L85"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.addExprs'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">addExprs'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> :\n  <span class=\"fn\">have <span class=\"fn\">u</span> := <span class=\"fn\">u</span>;\n  <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_inst</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddMonoid\">AddMonoid</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span></span> → <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span></span></div></div>","info":{"doc":"A type-safe analogue of `addExprs`. ","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.addExprs'","kind":"def","line":67,"name":"Mathlib.Tactic.Linarith.addExprs'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Verification.lean#L67-L76"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.mulExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">mulExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"`mulExpr n e` creates an `Expr` representing `n*e`.\nWhen elaborated, the coefficient will be a native numeral of the same type as `e`.\n","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.mulExpr","kind":"def","line":58,"name":"Mathlib.Tactic.Linarith.mulExpr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Verification.lean#L58-L65"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.mulExpr'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">mulExpr'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> :\n  <span class=\"fn\">have <span class=\"fn\">u</span> := <span class=\"fn\">u</span>;\n  <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span></div></div>","info":{"doc":"A typesafe version of `mulExpr`. ","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.mulExpr'","kind":"def","line":52,"name":"Mathlib.Tactic.Linarith.mulExpr'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Verification.lean#L52-L56"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Verification.html#Qq.ofNatQ\"><span class=\"name\">Qq</span>.<span class=\"name\">ofNatQ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> :\n  <span class=\"fn\">have <span class=\"fn\">u</span> := <span class=\"fn\">u</span>;\n  <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">«$α»</span></span>)</span> → <span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>) → <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span></span></span></div></div>","info":{"doc":"Typesafe conversion of `n : ℕ` to `Q($α)`. ","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Qq.ofNatQ","kind":"def","line":32,"name":"Qq.ofNatQ","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Tactic/Linarith/Verification.lean#L32-L41"}}],"imports":["Init","Mathlib.Util.Qq","Mathlib.Tactic.Linarith.Datatypes","Mathlib.Tactic.Linarith.Parsing"],"instances":[],"name":"Mathlib.Tactic.Linarith.Verification"}