{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.jordan_holder\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">jordan_holder</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s₁ </span><span class=\"fn\">s₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hb</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.head\">RelSeries.head</a> <span class=\"fn\">s₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.head\">RelSeries.head</a> <span class=\"fn\">s₂</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ht</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">s₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">s₂</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s₁</span>.<a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent\">Equivalent</a></span> <span class=\"fn\">s₂</span></span></div></div>","info":{"doc":"The **Jordan-Hölder** theorem, stated for any `JordanHolderLattice`.\nIf two composition series start and finish at the same place, they are equivalent. ","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.jordan_holder","kind":"theorem","line":400,"name":"CompositionSeries.jordan_holder","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L400-L418"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.exists_last_eq_snoc_equivalent\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">exists_last_eq_snoc_equivalent</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">X</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hm</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal\">JordanHolderLattice.IsMaximal</a> <span class=\"fn\">x</span> <span class=\"fn\">(<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">s</span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hb</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.head\">RelSeries.head</a> <span class=\"fn\">s</span></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∃ (<span class=\"fn\">t</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>),\n  <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.head\">RelSeries.head</a> <span class=\"fn\">t</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.head\">RelSeries.head</a> <span class=\"fn\">s</span></span> <a href=\"./Init/Prelude.html#And\">∧</a>     <span class=\"fn\"><span class=\"fn\">t</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.length\">length</a></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">s</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.length\">length</a></span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\">∃ (<span class=\"fn\">htx</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">t</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">x</span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.<a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent\">Equivalent</a></span> <span class=\"fn\">(<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.snoc\">RelSeries.snoc</a> <span class=\"fn\">t</span> <span class=\"fn\">(<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">s</span>)</span> <span class=\"fn\">⋯</span>)</span></span></span></span></div></div>","info":{"doc":"Given a `CompositionSeries`, `s`, and an element `x`\nsuch that `x` is maximal inside `s.last` there is a series, `t`,\nsuch that `t.last = x`, `t.head = s.head`\nand `snoc t s.last _` is equivalent to `s`. ","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.exists_last_eq_snoc_equivalent","kind":"theorem","line":360,"name":"CompositionSeries.exists_last_eq_snoc_equivalent","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L360-L398"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.eq_of_head_eq_head_of_last_eq_last_of_length_eq_zero\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">eq_of_head_eq_head_of_last_eq_last_of_length_eq_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s₁ </span><span class=\"fn\">s₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hb</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.head\">RelSeries.head</a> <span class=\"fn\">s₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.head\">RelSeries.head</a> <span class=\"fn\">s₂</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ht</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">s₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">s₂</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hs₁0</span> : <span class=\"fn\"><span class=\"fn\">s₁</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.length\">length</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">s₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">s₂</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.eq_of_head_eq_head_of_last_eq_last_of_length_eq_zero","kind":"theorem","line":347,"name":"CompositionSeries.eq_of_head_eq_head_of_last_eq_last_of_length_eq_zero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L347-L358"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.length_pos_of_head_eq_head_of_last_eq_last_of_length_pos\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">length_pos_of_head_eq_head_of_last_eq_last_of_length_pos</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s₁ </span><span class=\"fn\">s₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hb</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.head\">RelSeries.head</a> <span class=\"fn\">s₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.head\">RelSeries.head</a> <span class=\"fn\">s₂</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ht</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">s₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">s₂</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\"><span class=\"fn\">s₁</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.length\">length</a></span> → <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\"><span class=\"fn\">s₂</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.length\">length</a></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.length_pos_of_head_eq_head_of_last_eq_last_of_length_pos","kind":"theorem","line":340,"name":"CompositionSeries.length_pos_of_head_eq_head_of_last_eq_last_of_length_pos","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L340-L345"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.length_eq_zero_of_head_eq_head_of_last_eq_last_of_length_eq_zero\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">length_eq_zero_of_head_eq_head_of_last_eq_last_of_length_eq_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s₁ </span><span class=\"fn\">s₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hb</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.head\">RelSeries.head</a> <span class=\"fn\">s₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.head\">RelSeries.head</a> <span class=\"fn\">s₂</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ht</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">s₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">s₂</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hs₁</span> : <span class=\"fn\"><span class=\"fn\">s₁</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.length\">length</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">s₂</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.length\">length</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.length_eq_zero_of_head_eq_head_of_last_eq_last_of_length_eq_zero","kind":"theorem","line":333,"name":"CompositionSeries.length_eq_zero_of_head_eq_head_of_last_eq_last_of_length_eq_zero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L333-L338"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent.snoc_snoc_swap\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">Equivalent</span>.<span class=\"name\">snoc_snoc_swap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x₁ </span><span class=\"fn\">x₂ </span><span class=\"fn\">y₁ </span><span class=\"fn\">y₂</span> : <span class=\"fn\">X</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">hsat₁</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal\">JordanHolderLattice.IsMaximal</a> <span class=\"fn\">(<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">s</span>)</span> <span class=\"fn\">x₁</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">hsat₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal\">JordanHolderLattice.IsMaximal</a> <span class=\"fn\">(<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">s</span>)</span> <span class=\"fn\">x₂</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">hsaty₁</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal\">JordanHolderLattice.IsMaximal</a> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.snoc\">RelSeries.snoc</a> <span class=\"fn\">s</span> <span class=\"fn\">x₁</span> <span class=\"fn\">hsat₁</span>)</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">last</a></span> <span class=\"fn\">y₁</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">hsaty₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal\">JordanHolderLattice.IsMaximal</a> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.snoc\">RelSeries.snoc</a> <span class=\"fn\">s</span> <span class=\"fn\">x₂</span> <span class=\"fn\">hsat₂</span>)</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">last</a></span> <span class=\"fn\">y₂</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hr₁</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso\">JordanHolderLattice.Iso</a> <a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">s</span></span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">x₁</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">x₂</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">y₂</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hr₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso\">JordanHolderLattice.Iso</a> <a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">x₁</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">y₁</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">s</span></span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">x₂</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent\">Equivalent</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.snoc\">RelSeries.snoc</a> <span class=\"fn\">s</span> <span class=\"fn\">x₁</span> <span class=\"fn\">hsat₁</span>)</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.snoc\">snoc</a></span> <span class=\"fn\">y₁</span> <span class=\"fn\">hsaty₁</span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.snoc\">RelSeries.snoc</a> <span class=\"fn\">s</span> <span class=\"fn\">x₂</span> <span class=\"fn\">hsat₂</span>)</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.snoc\">snoc</a></span> <span class=\"fn\">y₂</span> <span class=\"fn\">hsaty₂</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent.snoc_snoc_swap","kind":"theorem","line":302,"name":"CompositionSeries.Equivalent.snoc_snoc_swap","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L302-L329"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent.length_eq\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">Equivalent</span>.<span class=\"name\">length_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s₁ </span><span class=\"fn\">s₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s₁</span>.<a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent\">Equivalent</a></span> <span class=\"fn\">s₂</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">s₁</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.length\">length</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">s₂</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.length\">length</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent.length_eq","kind":"theorem","line":299,"name":"CompositionSeries.Equivalent.length_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L299-L300"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent.snoc\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">Equivalent</span>.<span class=\"name\">snoc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s₁ </span><span class=\"fn\">s₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x₁ </span><span class=\"fn\">x₂</span> : <span class=\"fn\">X</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">hsat₁</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal\">JordanHolderLattice.IsMaximal</a> <span class=\"fn\">(<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">s₁</span>)</span> <span class=\"fn\">x₁</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">hsat₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal\">JordanHolderLattice.IsMaximal</a> <span class=\"fn\">(<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">s₂</span>)</span> <span class=\"fn\">x₂</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hequiv</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s₁</span>.<a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent\">Equivalent</a></span> <span class=\"fn\">s₂</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hlast</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso\">JordanHolderLattice.Iso</a> <a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">s₁</span></span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">x₁</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">s₂</span></span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">x₂</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent\">Equivalent</a> <span class=\"fn\">(<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.snoc\">RelSeries.snoc</a> <span class=\"fn\">s₁</span> <span class=\"fn\">x₁</span> <span class=\"fn\">hsat₁</span>)</span> <span class=\"fn\">(<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.snoc\">RelSeries.snoc</a> <span class=\"fn\">s₂</span> <span class=\"fn\">x₂</span> <span class=\"fn\">hsat₂</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent.snoc","kind":"theorem","line":285,"name":"CompositionSeries.Equivalent.snoc","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L285-L297"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent.smash\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">Equivalent</span>.<span class=\"name\">smash</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s₁ </span><span class=\"fn\">s₂ </span><span class=\"fn\">t₁ </span><span class=\"fn\">t₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hs</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">s₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.head\">RelSeries.head</a> <span class=\"fn\">s₂</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ht</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">t₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.head\">RelSeries.head</a> <span class=\"fn\">t₂</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₁</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s₁</span>.<a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent\">Equivalent</a></span> <span class=\"fn\">t₁</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₂</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s₂</span>.<a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent\">Equivalent</a></span> <span class=\"fn\">t₂</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent\">Equivalent</a> <span class=\"fn\">(<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.smash\">RelSeries.smash</a> <span class=\"fn\">s₁</span> <span class=\"fn\">s₂</span> <span class=\"fn\">hs</span>)</span> <span class=\"fn\">(<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.smash\">RelSeries.smash</a> <span class=\"fn\">t₁</span> <span class=\"fn\">t₂</span> <span class=\"fn\">ht</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent.smash","kind":"theorem","line":268,"name":"CompositionSeries.Equivalent.smash","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L268-L283"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent.trans\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">Equivalent</span>.<span class=\"name\">trans</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s₁ </span><span class=\"fn\">s₂ </span><span class=\"fn\">s₃</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₁</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s₁</span>.<a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent\">Equivalent</a></span> <span class=\"fn\">s₂</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₂</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s₂</span>.<a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent\">Equivalent</a></span> <span class=\"fn\">s₃</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s₁</span>.<a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent\">Equivalent</a></span> <span class=\"fn\">s₃</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent.trans","kind":"theorem","line":262,"name":"CompositionSeries.Equivalent.trans","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L262-L266"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent.symm\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">Equivalent</span>.<span class=\"name\">symm</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s₁ </span><span class=\"fn\">s₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s₁</span>.<a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent\">Equivalent</a></span> <span class=\"fn\">s₂</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s₂</span>.<a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent\">Equivalent</a></span> <span class=\"fn\">s₁</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent.symm","kind":"theorem","line":258,"name":"CompositionSeries.Equivalent.symm","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L258-L260"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent.refl\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">Equivalent</span>.<span class=\"name\">refl</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.<a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent\">Equivalent</a></span> <span class=\"fn\">s</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent.refl","kind":"theorem","line":254,"name":"CompositionSeries.Equivalent.refl","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L254-L256"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">Equivalent</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s₁ </span><span class=\"fn\">s₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>","info":{"doc":"Two `CompositionSeries X`, `s₁` and `s₂` are equivalent if there is a bijection\n`e : Fin s₁.length ≃ Fin s₂.length` such that for any `i`,\n`Iso (s₁ i) (s₁ i.succ) (s₂ (e i), s₂ (e i.succ))` ","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent","kind":"def","line":244,"name":"CompositionSeries.Equivalent","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L244-L250"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.snoc_eraseLast_last\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">snoc_eraseLast_last</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal\">JordanHolderLattice.IsMaximal</a> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.eraseLast\">RelSeries.eraseLast</a> <span class=\"fn\">s</span>)</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">last</a></span> <span class=\"fn\">(<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">s</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.eraseLast\">RelSeries.eraseLast</a> <span class=\"fn\">s</span>)</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.snoc\">snoc</a></span> <span class=\"fn\">(<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">s</span>)</span> <span class=\"fn\">h</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">s</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.snoc_eraseLast_last","kind":"theorem","line":237,"name":"CompositionSeries.snoc_eraseLast_last","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L237-L242"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.eq_snoc_eraseLast\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">eq_snoc_eraseLast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\"><span class=\"fn\">s</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.length\">length</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">s</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.eraseLast\">RelSeries.eraseLast</a> <span class=\"fn\">s</span>)</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.snoc\">snoc</a></span> <span class=\"fn\">(<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">s</span>)</span> <span class=\"fn\">⋯</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.eq_snoc_eraseLast","kind":"theorem","line":231,"name":"CompositionSeries.eq_snoc_eraseLast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L231-L235"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.isMaximal_eraseLast_last\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">isMaximal_eraseLast_last</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\"><span class=\"fn\">s</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.length\">length</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal\">JordanHolderLattice.IsMaximal</a> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.eraseLast\">RelSeries.eraseLast</a> <span class=\"fn\">s</span>)</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">last</a></span> <span class=\"fn\">(<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">s</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.isMaximal_eraseLast_last","kind":"theorem","line":223,"name":"CompositionSeries.isMaximal_eraseLast_last","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L223-L229"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.lt_last_of_mem_eraseLast\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">lt_last_of_mem_eraseLast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">X</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\"><span class=\"fn\">s</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.length\">length</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hx</span> : <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.eraseLast\">RelSeries.eraseLast</a> <span class=\"fn\">s</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">s</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.lt_last_of_mem_eraseLast","kind":"theorem","line":219,"name":"CompositionSeries.lt_last_of_mem_eraseLast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L219-L221"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.mem_eraseLast\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">mem_eraseLast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">X</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\"><span class=\"fn\">s</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.length\">length</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.eraseLast\">RelSeries.eraseLast</a> <span class=\"fn\">s</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">x</span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">s</span></span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">s</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.mem_eraseLast","kind":"theorem","line":209,"name":"CompositionSeries.mem_eraseLast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L209-L217"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.mem_eraseLast_of_ne_of_mem\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">mem_eraseLast_of_ne_of_mem</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">X</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hx</span> : <span class=\"fn\">x</span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">s</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hxs</span> : <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">s</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.eraseLast\">RelSeries.eraseLast</a> <span class=\"fn\">s</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.mem_eraseLast_of_ne_of_mem","kind":"theorem","line":200,"name":"CompositionSeries.mem_eraseLast_of_ne_of_mem","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L200-L207"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.last_eraseLast_le\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">last_eraseLast_le</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.eraseLast\">RelSeries.eraseLast</a> <span class=\"fn\">s</span>)</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">last</a></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">s</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.last_eraseLast_le","kind":"theorem","line":197,"name":"CompositionSeries.last_eraseLast_le","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L197-L198"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.head_le_of_mem\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">head_le_of_mem</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">X</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hx</span> : <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">s</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.head\">RelSeries.head</a> <span class=\"fn\">s</span></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.head_le_of_mem","kind":"theorem","line":193,"name":"CompositionSeries.head_le_of_mem","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L193-L195"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.head_le\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">head_le</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Fin\">Fin</a> (<span class=\"fn\"><span class=\"fn\">s</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.length\">length</a></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.head\">RelSeries.head</a> <span class=\"fn\">s</span></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.toFun\">toFun</a></span> <span class=\"fn\">i</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.head_le","kind":"theorem","line":189,"name":"CompositionSeries.head_le","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L189-L191"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.le_last_of_mem\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">le_last_of_mem</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">X</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hx</span> : <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">s</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">s</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.le_last_of_mem","kind":"theorem","line":185,"name":"CompositionSeries.le_last_of_mem","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L185-L187"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.le_last\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">le_last</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Fin\">Fin</a> (<span class=\"fn\"><span class=\"fn\">s</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.length\">length</a></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.toFun\">toFun</a></span> <span class=\"fn\">i</span></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Mathlib/Order/RelSeries.html#RelSeries.last\">RelSeries.last</a> <span class=\"fn\">s</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.le_last","kind":"theorem","line":181,"name":"CompositionSeries.le_last","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L181-L183"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.ext_iff\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">ext_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s₁ </span><span class=\"fn\">s₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">s₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">s₂</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∀ (<span class=\"fn\">x</span> : <span class=\"fn\">X</span>), <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">s₁</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">s₂</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.ext_iff","kind":"theorem","line":173,"name":"CompositionSeries.ext_iff","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L173-L173"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.ext\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s₁ </span><span class=\"fn\">s₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">∀ (<span class=\"fn\">x</span> : <span class=\"fn\">X</span>), <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">s₁</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">s₂</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">s₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">s₂</span></div></div>","info":{"doc":"Two `CompositionSeries` are equal if they have the same elements. See also `ext_fun`. ","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.ext","kind":"theorem","line":172,"name":"CompositionSeries.ext","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L172-L179"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.toList_nodup\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">toList_nodup</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.toList\">RelSeries.toList</a> <span class=\"fn\">s</span>)</span>.<a href=\"./Init/Data/List/Basic.html#List.Nodup\">Nodup</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.toList_nodup","kind":"theorem","line":169,"name":"CompositionSeries.toList_nodup","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L169-L170"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.toList_sorted\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">toList_sorted</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.toList\">RelSeries.toList</a> <span class=\"fn\">s</span>)</span>.<a href=\"./Mathlib/Data/List/Sort.html#List.SortedLT\">SortedLT</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.toList_sorted","kind":"theorem","line":164,"name":"CompositionSeries.toList_sorted","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L164-L167"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.total\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">total</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x </span><span class=\"fn\">y</span> : <span class=\"fn\">X</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hx</span> : <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">s</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hy</span> : <span class=\"fn\">y</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">s</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">y</span> <a href=\"./Init/Prelude.html#Or\">∨</a> <span class=\"fn\">y</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">x</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.total","kind":"theorem","line":158,"name":"CompositionSeries.total","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L158-L162"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.inj\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">inj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">i </span><span class=\"fn\">j</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Fin\">Fin</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.length\">length</a></span>.<a href=\"./Init/Prelude.html#Nat.succ\">succ</a></span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.toFun\">toFun</a></span> <span class=\"fn\">i</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.toFun\">toFun</a></span> <span class=\"fn\">j</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">i</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">j</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.inj","kind":"theorem","line":154,"name":"CompositionSeries.inj","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L154-L156"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.injective\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">injective</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Function.html#Function.Injective\">Function.Injective</a> <span class=\"fn\"><span class=\"fn\">s</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.toFun\">toFun</a></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.injective","kind":"theorem","line":151,"name":"CompositionSeries.injective","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L151-L152"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.strictMono\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">strictMono</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Order/Monotone/Defs.html#StrictMono\">StrictMono</a> <span class=\"fn\"><span class=\"fn\">s</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.toFun\">toFun</a></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.strictMono","kind":"theorem","line":148,"name":"CompositionSeries.strictMono","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L148-L149"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries.lt_succ\"><span class=\"name\">CompositionSeries</span>.<span class=\"name\">lt_succ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\">CompositionSeries</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Fin\">Fin</a> <span class=\"fn\"><span class=\"fn\">s</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.length\">length</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.toFun\">toFun</a></span> <span class=\"fn\"><span class=\"fn\">i</span>.<a href=\"./Init/Data/Fin/Basic.html#Fin.castSucc\">castSucc</a></span></span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">s</span>.<a href=\"./Mathlib/Order/RelSeries.html#RelSeries.toFun\">toFun</a></span> <span class=\"fn\"><span class=\"fn\">i</span>.<a href=\"./Init/Data/Fin/Basic.html#Fin.succ\">succ</a></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries.lt_succ","kind":"theorem","line":144,"name":"CompositionSeries.lt_succ","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L144-L146"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#CompositionSeries\"><span class=\"name\">CompositionSeries</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>","info":{"doc":"A `CompositionSeries X` is a finite nonempty series of elements of a\n`JordanHolderLattice` such that each element is maximal inside the next. The length of a\n`CompositionSeries X` is one less than the number of elements in the series.\nNote that there is no stipulation that a series start from the bottom of the lattice and finish at\nthe top. For a composition series `s`, `s.last` is the largest element of the series,\nand `s.head` is the least element.\n","docLink":"./Mathlib/Order/JordanHolder.html#CompositionSeries","kind":"def","line":130,"name":"CompositionSeries","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L130-L138"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal.iso_refl\"><span class=\"name\">JordanHolderLattice</span>.<span class=\"name\">IsMaximal</span>.<span class=\"name\">iso_refl</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x </span><span class=\"fn\">y</span> : <span class=\"fn\">X</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal\">IsMaximal</a> <span class=\"fn\">x</span> <span class=\"fn\">y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso\">Iso</a> <a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">x</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">y</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">x</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">y</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal.iso_refl","kind":"theorem","line":118,"name":"JordanHolderLattice.IsMaximal.iso_refl","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L118-L120"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.second_iso_of_eq\"><span class=\"name\">JordanHolderLattice</span>.<span class=\"name\">second_iso_of_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x </span><span class=\"fn\">y </span><span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">X</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hm</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal\">IsMaximal</a> <span class=\"fn\">x</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ha</span> : <span class=\"fn\"><span class=\"fn\">x</span> ⊔ <span class=\"fn\">y</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hb</span> : <span class=\"fn\"><span class=\"fn\">x</span> ⊓ <span class=\"fn\">y</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso\">Iso</a> <a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">x</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">a</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">b</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">y</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.second_iso_of_eq","kind":"theorem","line":115,"name":"JordanHolderLattice.second_iso_of_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L115-L116"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.isMaximal_of_eq_inf\"><span class=\"name\">JordanHolderLattice</span>.<span class=\"name\">isMaximal_of_eq_inf</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x </span><span class=\"fn\">b</span> : <span class=\"fn\">X</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">y</span> : <span class=\"fn\">X</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ha</span> : <span class=\"fn\"><span class=\"fn\">x</span> ⊓ <span class=\"fn\">y</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hxy</span> : <span class=\"fn\">x</span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">y</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hxb</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal\">IsMaximal</a> <span class=\"fn\">x</span> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hyb</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal\">IsMaximal</a> <span class=\"fn\">y</span> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal\">IsMaximal</a> <span class=\"fn\">a</span> <span class=\"fn\">y</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.isMaximal_of_eq_inf","kind":"theorem","line":109,"name":"JordanHolderLattice.isMaximal_of_eq_inf","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L109-L113"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.isMaximal_inf_right_of_isMaximal_sup\"><span class=\"name\">JordanHolderLattice</span>.<span class=\"name\">isMaximal_inf_right_of_isMaximal_sup</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x </span><span class=\"fn\">y</span> : <span class=\"fn\">X</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hxz</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal\">IsMaximal</a> <span class=\"fn\">x</span> <span class=\"fn\">(<span class=\"fn\">x</span> ⊔ <span class=\"fn\">y</span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hyz</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal\">IsMaximal</a> <span class=\"fn\">y</span> <span class=\"fn\">(<span class=\"fn\">x</span> ⊔ <span class=\"fn\">y</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal\">IsMaximal</a> <span class=\"fn\">(<span class=\"fn\">x</span> ⊓ <span class=\"fn\">y</span>)</span> <span class=\"fn\">y</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.isMaximal_inf_right_of_isMaximal_sup","kind":"theorem","line":103,"name":"JordanHolderLattice.isMaximal_inf_right_of_isMaximal_sup","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L103-L107"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.second_iso\"><span class=\"name\">JordanHolderLattice</span>.<span class=\"name\">second_iso</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">inst✝</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x </span><span class=\"fn\">y</span> : <span class=\"fn\">X</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal\">IsMaximal</a> <span class=\"fn\">x</span> <span class=\"fn\">(<span class=\"fn\">x</span> ⊔ <span class=\"fn\">y</span>)</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso\">Iso</a> <a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">x</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\"><span class=\"fn\">x</span> ⊔ <span class=\"fn\">y</span></span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\"><span class=\"fn\">x</span> ⊓ <span class=\"fn\">y</span></span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">y</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.second_iso","kind":"theorem","line":97,"name":"JordanHolderLattice.second_iso","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L97-L97"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.iso_trans\"><span class=\"name\">JordanHolderLattice</span>.<span class=\"name\">iso_trans</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">inst✝</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x </span><span class=\"fn\">y </span><span class=\"fn\">z</span> : <span class=\"fn\">X</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">X</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso\">Iso</a> <span class=\"fn\">x</span> <span class=\"fn\">y</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso\">Iso</a> <span class=\"fn\">y</span> <span class=\"fn\">z</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso\">Iso</a> <span class=\"fn\">x</span> <span class=\"fn\">z</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.iso_trans","kind":"theorem","line":96,"name":"JordanHolderLattice.iso_trans","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L96-L96"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.iso_symm\"><span class=\"name\">JordanHolderLattice</span>.<span class=\"name\">iso_symm</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">inst✝</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x </span><span class=\"fn\">y</span> : <span class=\"fn\">X</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">X</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso\">Iso</a> <span class=\"fn\">x</span> <span class=\"fn\">y</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso\">Iso</a> <span class=\"fn\">y</span> <span class=\"fn\">x</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.iso_symm","kind":"theorem","line":95,"name":"JordanHolderLattice.iso_symm","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L95-L95"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso\"><span class=\"name\">JordanHolderLattice</span>.<span class=\"name\">Iso</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">inst✝</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">X</span> → <span class=\"fn\">X</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">X</span> → <a href=\"./foundational_types.html\">Prop</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso","kind":"def","line":94,"name":"JordanHolderLattice.Iso","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L94-L94"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.isMaximal_inf_left_of_isMaximal_sup\"><span class=\"name\">JordanHolderLattice</span>.<span class=\"name\">isMaximal_inf_left_of_isMaximal_sup</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">inst✝</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x </span><span class=\"fn\">y</span> : <span class=\"fn\">X</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal\">IsMaximal</a> <span class=\"fn\">x</span> <span class=\"fn\">(<span class=\"fn\">x</span> ⊔ <span class=\"fn\">y</span>)</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal\">IsMaximal</a> <span class=\"fn\">y</span> <span class=\"fn\">(<span class=\"fn\">x</span> ⊔ <span class=\"fn\">y</span>)</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal\">IsMaximal</a> <span class=\"fn\">(<span class=\"fn\">x</span> ⊓ <span class=\"fn\">y</span>)</span> <span class=\"fn\">x</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.isMaximal_inf_left_of_isMaximal_sup","kind":"theorem","line":92,"name":"JordanHolderLattice.isMaximal_inf_left_of_isMaximal_sup","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L92-L92"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.sup_eq_of_isMaximal\"><span class=\"name\">JordanHolderLattice</span>.<span class=\"name\">sup_eq_of_isMaximal</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">inst✝</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x </span><span class=\"fn\">y </span><span class=\"fn\">z</span> : <span class=\"fn\">X</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal\">IsMaximal</a> <span class=\"fn\">x</span> <span class=\"fn\">z</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal\">IsMaximal</a> <span class=\"fn\">y</span> <span class=\"fn\">z</span></span> → <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">y</span> → <span class=\"fn\"><span class=\"fn\">x</span> ⊔ <span class=\"fn\">y</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">z</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.sup_eq_of_isMaximal","kind":"theorem","line":91,"name":"JordanHolderLattice.sup_eq_of_isMaximal","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L91-L91"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.lt_of_isMaximal\"><span class=\"name\">JordanHolderLattice</span>.<span class=\"name\">lt_of_isMaximal</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">inst✝</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x </span><span class=\"fn\">y</span> : <span class=\"fn\">X</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal\">IsMaximal</a> <span class=\"fn\">x</span> <span class=\"fn\">y</span></span> → <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">y</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.lt_of_isMaximal","kind":"theorem","line":90,"name":"JordanHolderLattice.lt_of_isMaximal","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L90-L90"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal\"><span class=\"name\">JordanHolderLattice</span>.<span class=\"name\">IsMaximal</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">inst✝</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">X</span> → <span class=\"fn\">X</span> → <a href=\"./foundational_types.html\">Prop</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal","kind":"def","line":89,"name":"JordanHolderLattice.IsMaximal","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L89-L89"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.mk\"><span class=\"name\">JordanHolderLattice</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">IsMaximal</span> : <span class=\"fn\"><span class=\"fn\">X</span> → <span class=\"fn\">X</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lt_of_isMaximal</span> : <span class=\"fn\">∀ {<span class=\"fn\">x </span><span class=\"fn\">y</span> : <span class=\"fn\">X</span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">IsMaximal</span> <span class=\"fn\">x</span> <span class=\"fn\">y</span></span> → <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">y</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sup_eq_of_isMaximal</span> : <span class=\"fn\">∀ {<span class=\"fn\">x </span><span class=\"fn\">y </span><span class=\"fn\">z</span> : <span class=\"fn\">X</span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">IsMaximal</span> <span class=\"fn\">x</span> <span class=\"fn\">z</span></span> → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">IsMaximal</span> <span class=\"fn\">y</span> <span class=\"fn\">z</span></span> → <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">y</span> → <span class=\"fn\"><span class=\"fn\">x</span> ⊔ <span class=\"fn\">y</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">z</span></span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">isMaximal_inf_left_of_isMaximal_sup</span> : <span class=\"fn\">∀ {<span class=\"fn\">x </span><span class=\"fn\">y</span> : <span class=\"fn\">X</span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">IsMaximal</span> <span class=\"fn\">x</span> <span class=\"fn\">(<span class=\"fn\">x</span> ⊔ <span class=\"fn\">y</span>)</span></span> → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">IsMaximal</span> <span class=\"fn\">y</span> <span class=\"fn\">(<span class=\"fn\">x</span> ⊔ <span class=\"fn\">y</span>)</span></span> → <span class=\"fn\"><span class=\"fn\">IsMaximal</span> <span class=\"fn\">(<span class=\"fn\">x</span> ⊓ <span class=\"fn\">y</span>)</span> <span class=\"fn\">x</span></span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">Iso</span> : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">X</span> → <span class=\"fn\">X</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">X</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iso_symm</span> : <span class=\"fn\">∀ {<span class=\"fn\">x </span><span class=\"fn\">y</span> : <span class=\"fn\">X</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">X</span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">Iso</span> <span class=\"fn\">x</span> <span class=\"fn\">y</span></span> → <span class=\"fn\"><span class=\"fn\">Iso</span> <span class=\"fn\">y</span> <span class=\"fn\">x</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iso_trans</span> : <span class=\"fn\">∀ {<span class=\"fn\">x </span><span class=\"fn\">y </span><span class=\"fn\">z</span> : <span class=\"fn\">X</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">X</span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">Iso</span> <span class=\"fn\">x</span> <span class=\"fn\">y</span></span> → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">Iso</span> <span class=\"fn\">y</span> <span class=\"fn\">z</span></span> → <span class=\"fn\"><span class=\"fn\">Iso</span> <span class=\"fn\">x</span> <span class=\"fn\">z</span></span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">second_iso</span> : <span class=\"fn\">∀ {<span class=\"fn\">x </span><span class=\"fn\">y</span> : <span class=\"fn\">X</span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">IsMaximal</span> <span class=\"fn\">x</span> <span class=\"fn\">(<span class=\"fn\">x</span> ⊔ <span class=\"fn\">y</span>)</span></span> → <span class=\"fn\"><span class=\"fn\">Iso</span> <a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">x</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\"><span class=\"fn\">x</span> ⊔ <span class=\"fn\">y</span></span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\"><span class=\"fn\">x</span> ⊓ <span class=\"fn\">y</span></span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">y</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\">JordanHolderLattice</a> <span class=\"fn\">X</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Order/JordanHolder.html#JordanHolderLattice.mk","kind":"ctor","line":88,"name":"JordanHolderLattice.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L88-L88"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">class</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Order/JordanHolder.html#JordanHolderLattice\"><span class=\"name\">JordanHolderLattice</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">X</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Order/Lattice.html#Lattice\">Lattice</a> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>","info":{"doc":"A `JordanHolderLattice` is the class for which the Jordan Hölder theorem is proved. A\nJordan Hölder lattice is a lattice equipped with a notion of maximality, `IsMaximal`, and a notion\nof isomorphism of pairs `Iso`. In the example of subgroups of a group, `IsMaximal H K` means that\n`H` is a maximal normal subgroup of `K`, and `Iso (H₁, K₁) (H₂, K₂)` means that the quotient\n`H₁ / K₁` is isomorphic to the quotient `H₂ / K₂`. `Iso` must be symmetric and transitive and must\nsatisfy the second isomorphism theorem `Iso (H, H ⊔ K) (H ⊓ K, K)`.\nExamples include `Subgroup G` if `G` is a group, and `Submodule R M` if `M` is an `R`-module.\n","docLink":"./Mathlib/Order/JordanHolder.html#JordanHolderLattice","kind":"class","line":80,"name":"JordanHolderLattice","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Order/JordanHolder.lean#L80-L97"}}],"imports":["Init","Mathlib.Order.Lattice","Mathlib.Data.List.Sort","Mathlib.Logic.Equiv.Fin.Basic","Mathlib.Logic.Equiv.Functor","Mathlib.Data.Fintype.Pigeonhole","Mathlib.Order.RelSeries"],"instances":[],"name":"Mathlib.Order.JordanHolder"}